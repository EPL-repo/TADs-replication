#!/usr/bin/perl -w
use Imager;
#
#
# 
#  script: plot_sigma_values_EUseq_v1.pl
#  
#  published in: Macheret M., and Halazonetis, T.D.
#                Intragenic origins due to short G1 phases underlie oncogene-induced DNA replication stress.
#                Nature 2018.
#
#  disclaimers: no claims are made that this script performs any specific task
#               not responsible for any damage/loss caused by using this script
#               script is to be used only for research purposes
#
#  SCRIPT REQUIREMENT: Imager library/package for Perl
#               
#  prerequisites: good knowledge of linux and perl are required to run this script
#                 no support can be provided to troubleshoot this script
#                 if you have difficulties, please contact your local linux/perl expert
#
#  VERY IMPORTANT: works with the masked human genome assembly: GRCh37/hg19
#             the sam files must be aligned to the above assembly 
#
#  copyright (2017): Thanos D. Halazonetis, University of Geneva
#
#
#  VERY IMPORTANT: requires 4 EUseq sigma files as input (if you have fewer files, input the same file more than once) 
#
#  usage: plot_sigma_values_EUseq_v1.pl  max(gm/lm/ma)  chrN  graph_width(odd)  graph_center  value_from_file_1 _2 _3 _4  value_scale_1 _2 _3 _4
#
#    example usage: plot_sigma_values_EUseq_v1.pl    lm  chr7  701  500    2 2 2 2     1 1 1 1
#
#      where:
#                          gm = global maximum of values in all chromosomes
#                             alternative:   lm = local maximum of values in region plotted
#                             alternative:   ma = manual entry of maximum, in which case,
#                                    you must specify the value in the line below, for example:  $manual_max=1000;
#
$manual_max=1000;
#
#                          chr7 = chromosome to be plotted (chr1 - chrX)
#
#                          701 = width of plot in bins, must be an odd number
#
#                          500 = number of bin at center of plot
#                                (i.e. position in the chromosome: with bin_size=10,000, bin 500=5 Mb)
#
#                          2 2 2 2 = value to be plotted for each file that is plotted
#                                2 2 2 2 applies to 4 files; if these files are of the format: -------_sigma_select_EU_0b.csv,
#                                    then value 2 corresponds to: sigma value with background (noise) subtraction, select values trimmed
#                                    these values recommended for  EUseq  data
#                                    see "DATA PLOTTED IN OUTPUT FILES" below to relate the number to the specific value to be plotted
#
#                          1 1 1 1 = scaling of values to be able to plot values of different scales
#                                in this case, the values of all files will be multiplied by 1
#                                you can run the program with values: 1 1 1 1
#                                then the program outputs recommended scaling, as follows: 
#                                      "Suggested scaling for files based on global maxima (to input in command line): 0.95 0.97 1.03 1"
#                    
#
#      the file names to be plotted and the number of files must be inserted manually using a text editor in the lines below:      
#          example line :  $csv_file_Name[1]="OEcycEUHU06--EUfor_bin-size_1000_quality_37_chr1-X_sigma_select_EU_0b.csv";
#          example line :  $csv_file_Name[2]="OEcycEUHU06--EUrev_bin-size_1000_quality_37_chr1-X_sigma_select_EU_0b.csv";
#          example line :  $csv_file_Name[3]="NEcycEUHU06--EUfor_bin-size_1000_quality_37_chr1-X_sigma_select_EU_0b.csv";
#          example line :  $csv_file_Name[4]="NEcycEUHU06--EUrev_bin-size_1000_quality_37_chr1-X_sigma_select_EU_0b.csv";
#
#      for proper coloring, files with odd ([1], [3]) numbers must be forward (for) reads
#      for proper coloring, files with even ([2], [4]) numbers must be reverse (rev) reads
#
$csv_file_Name[1]="OEcycEUHU06--EUfor_bin-size_10000_quality_37_chr1-X_sigma_all_EU_0b.csv";
$csv_file_Name[2]="OEcycEUHU06--EUrev_bin-size_10000_quality_37_chr1-X_sigma_all_EU_0b.csv";
$csv_file_Name[3]="NEcycEHU14EU--EUfor_bin-size_10000_quality_37_chr1-X_sigma_all_EU_0b.csv";
$csv_file_Name[4]="NEcycEHU14EU--EUrev_bin-size_10000_quality_37_chr1-X_sigma_all_EU_0b.csv";
#
#  files to be plotted can be of the format:  ---_sigma_select_EU_0b.csv   or  ---_sigma_all_EU_0b.csv
#      generated by script:  calculate_sigma_from_number_hits_per_bin_EUseq_v1.pl
#
#  requires (optionally) the file:    GeneD_OiRD_ReplT_interpolated__bin-size_10000_chr1-X_0b.csv
#      to show replication timing profile and gene annotations
#
#  requires (optionally) the file:    Origin_List_bin-size_10000_Table_S1.csv
#      to show the positions of origins identified in U2OS cells
#      to specify if the positions of origins are to be shown, modify the line below:  $show_origins="yes";
#             otherwise:   $show_origins="no";
#
$show_origins="no";
#
#
#
#
#
#
#
# DATA PLOTTED IN OUTPUT FILES
#
#
# FILE: -------_sigma_select_EU_0b.csv
#
# for each genomic bin:
#
# 1 = $sigma_bin_mb_totalSD_sm        sigma value with background (noise) subtraction, all values smoothened
# 2 = $sigma_bin_mb_totalSD_tm        sigma value with background (noise) subtraction, high values trimmed
# 3 = $sigma_bin_totalSD_sm           sigma value without background (noise) subtraction, all values smoothened
# 4 = $sigma_bin_totalSD_tm           sigma value without background (noise) subtraction, high values trimmed
# 5 = $adjust                         sequence coverage of genomic DNA sequencing (reflecting all sequencing biases)  
#
#
# FILE: -------_sigma_all_EU_0b.csv
#
# for each genomic bin:
#
#  1 = $sigma_bin_mb_totalSD_sm        sigma value with background (noise) subtraction, all values smoothened
#  2 = $sigma_bin_mb_totalSD_tm        sigma value with background (noise) subtraction, high values trimmed
#  3 = $sigma_bin_totalSD_sm           sigma value without background (noise) subtraction, all values smoothened
#  4 = $sigma_bin_totalSD_tm           sigma value without background (noise) subtraction, high values trimmed
#  5 = $adjust                         sequence coverage of genomic DNA sequencing (reflecting all sequencing biases)  
#  6 = $sigma_bin_mb_totalSD           sigma value with background (noise) subtraction
#  7 = $sigma_bin_totalSD              sigma value without background (noise) subtraction
#  8 = $sigma_bin_mb_totalSD_log2      sigma value with background (noise) subtraction, converted to log2
#  9 = $sigma_bin_mb_totalSD_sm_log2   sigma value with background (noise) subtraction, all values smoothened, converted to log2
# 10 = $sigma_bin_mb_totalSD_tm_log2   sigma value with background (noise) subtraction, high values trimmed, converted to log2
# 11 = $adjbin                         number of sequences per bin, adjusted for all sequencing biases (using $adjust)
# 12 = $adjbin_mb                      number of sequences per bin with background (noise) subtraction, adjusted for all sequencing biases (using $adjust)
# 13 = $adjbin_SD                      standard deviation of adjbin values
# 14 = $bin                            number of sequences per bin
#
#
#
#
#
#
print "\n\n";
#
$draw_horizontal_ticks=0;   # to not draw horizontal ticks
#$draw_horizontal_ticks=1;   # to draw horizontal ticks
#
#
##
# process csv file names
#
$file_number=4;
print "File Name Info:\n\n";
print "Number of csv files to be plotted: $file_number\n\n";
for ($loopf=1; $loopf<=$file_number; $loopf++) {
    @get_File_Name = split("_bin-size_",$csv_file_Name[$loopf]);
    $sample_name_f[$loopf] = $get_File_Name[0];
    @get_File_Name_2 = split("_",$get_File_Name[1]);
    $bin_size_f[$loopf] = $get_File_Name_2[0];
    $all_mbrsm_f[$loopf] = $get_File_Name_2[$#get_File_Name_2-1];
    print "csv $loopf:    $csv_file_Name[$loopf]\n";
    print "      Sample: $sample_name_f[$loopf]     Bin: $bin_size_f[$loopf]     File type: sigma_$all_mbrsm_f[$loopf]\n\n";
}
#
for ($loopf=1; $loopf<=$file_number; $loopf++) {
    if (!-r "$csv_file_Name[$loopf]" ) {
        print "\nFATAL ERROR:  file: $csv_file_Name[$loopf]\n        non-existent or not readable\n\n";
        print "usage: plot_sigma_values_EUseq_v1.pl  max(gm/lm/ma)  chrN  graph_width(odd)  graph_center  value_from_file_1 _2 _3 _4  value_scale_1 _2 _3 _4\n";
        print "example usage: plot_sigma_values_EUseq_v1.pl    gm  chr7  701  500    2 2 2 2     1 1 1 1\n\n";
        exit;
    }
}
#
for ($loopf=2; $loopf<=$file_number; $loopf++) {
    if ($bin_size_f[1]!=$bin_size_f[$loopf]) {
        print "\nFATAL ERROR: csv files to be plotted have different bin sizes\n\n";
        print "usage: plot_sigma_values_EUseq_v1.pl  max(gm/lm/ma)  chrN  graph_width(odd)  graph_center  value_from_file_1 _2 _3 _4  value_scale_1 _2 _3 _4\n";
        print "example usage: plot_sigma_values_EUseq_v1.pl    gm  chr7  701  500    2 2 2 2     1 1 1 1\n\n";
        exit;
    }
}
#
$bin_size=$bin_size_f[1];
$max_chr_size=250000000;
$max_number_bins=$max_chr_size/$bin_size;
#
#
#
$maximum_flag=$ARGV[0]; # global or local or manual (gm or lm or ma)
#
if ($maximum_flag ne "gm" && $maximum_flag ne "lm" && $maximum_flag ne "ma") {
    print "\nFATAL ERROR: Maximum flag (max) not a valid name: gm or lm or ma\n\n";
        print "usage: plot_sigma_values_EUseq_v1.pl  max(gm/lm/ma)  chrN  graph_width(odd)  graph_center  value_from_file_1 _2 _3 _4  value_scale_1 _2 _3 _4\n";
        print "example usage: plot_sigma_values_EUseq_v1.pl    gm  chr7  701  500    2 2 2 2     1 1 1 1\n\n";
    exit;
}
#
#
$chromosome=$ARGV[1];
@chr_temp=split("chr",$chromosome);
$chr_number=$chr_temp[1];
if ($chr_number eq "X") {$chr_number=23}
#
if ($chr_number ne "1") {
if ($chr_number ne "2") {
if ($chr_number ne "3") {
if ($chr_number ne "4") {
if ($chr_number ne "5") {
if ($chr_number ne "6") {
if ($chr_number ne "7") {
if ($chr_number ne "8") {
if ($chr_number ne "9") {
if ($chr_number ne "10") {
if ($chr_number ne "11") {
if ($chr_number ne "12") {
if ($chr_number ne "13") {
if ($chr_number ne "14") {
if ($chr_number ne "15") {
if ($chr_number ne "16") {
if ($chr_number ne "17") {
if ($chr_number ne "18") {
if ($chr_number ne "19") {
if ($chr_number ne "20") {
if ($chr_number ne "21") {
if ($chr_number ne "22") {
if ($chr_number ne "23") {
    print "\nFATAL ERROR: Chromosome number not valid\n\n";
        print "usage: plot_sigma_values_EUseq_v1.pl  max(gm/lm/ma)  chrN  graph_width(odd)  graph_center  value_from_file_1 _2 _3 _4  value_scale_1 _2 _3 _4\n";
        print "example usage: plot_sigma_values_EUseq_v1.pl    gm  chr7  701  500    2 2 2 2     1 1 1 1\n\n";
    exit;
}}}}} }}}}} }}}}} }}}}} }}}
#
$graph_length=$ARGV[2];
if ( $graph_length/2 == int($graph_length/2) || $graph_length != int($graph_length)) {
    print "\nFATAL ERROR: Graph Width ($graph_length) must be odd, integer number\n\n";
        print "usage: plot_sigma_values_EUseq_v1.pl  max(gm/lm/ma)  chrN  graph_width(odd)  graph_center  value_from_file_1 _2 _3 _4  value_scale_1 _2 _3 _4\n";
        print "example usage: plot_sigma_values_EUseq_v1.pl    gm  chr7  701  500    2 2 2 2     1 1 1 1\n\n";
    exit;
}
#
$peak_position=$ARGV[3]-0;  # zero base
$peak_pos_as_input=$ARGV[3];
#
if ( $peak_pos_as_input != int($peak_pos_as_input)) {
    print "\nFATAL ERROR: Graph Center ($peak_pos_as_input) must be integer number\n\n";
        print "usage: plot_sigma_values_EUseq_v1.pl  max(gm/lm/ma)  chrN  graph_width(odd)  graph_center  value_from_file_1 _2 _3 _4  value_scale_1 _2 _3 _4\n";
        print "example usage: plot_sigma_values_EUseq_v1.pl    gm  chr7  701  500    2 2 2 2     1 1 1 1\n\n";
    exit;
}
#
# specify chr_size
#
$chr_size[1]=250000000/$bin_size;
$chr_size[2]=244000000/$bin_size;
$chr_size[3]=199000000/$bin_size;
$chr_size[4]=192000000/$bin_size;
$chr_size[5]=181000000/$bin_size;
$chr_size[6]=172000000/$bin_size;
$chr_size[7]=160000000/$bin_size;
$chr_size[8]=147000000/$bin_size;
$chr_size[9]=142000000/$bin_size;
$chr_size[10]=136000000/$bin_size;
$chr_size[11]=136000000/$bin_size;
$chr_size[12]=134000000/$bin_size;
$chr_size[13]=116000000/$bin_size;
$chr_size[14]=108000000/$bin_size;
$chr_size[15]=103000000/$bin_size;
$chr_size[16]=91000000/$bin_size;
$chr_size[17]=82000000/$bin_size;
$chr_size[18]=79000000/$bin_size;
$chr_size[19]=60000000/$bin_size;
$chr_size[20]=64000000/$bin_size;
$chr_size[21]=49000000/$bin_size;
$chr_size[22]=52000000/$bin_size;
$chr_size[23]=156000000/$bin_size;
#
$number_chr_bins=$chr_size[$chr_number];
#
# test if selected peak position is too close to chromosome ends
#
if ($peak_pos_as_input < int($graph_length/2 + 1) ) {
    $temp_var=int($graph_length/2 + 1);
    print "\nFATAL ERROR: Graph Center ($peak_pos_as_input) is too close to start of chromosome\n";
    print "    must be equal or greater than: $temp_var\n\n"; 
        print "usage: plot_sigma_values_EUseq_v1.pl  max(gm/lm/ma)  chrN  graph_width(odd)  graph_center  value_from_file_1 _2 _3 _4  value_scale_1 _2 _3 _4\n";
        print "example usage: plot_sigma_values_EUseq_v1.pl    gm  chr7  701  500    2 2 2 2     1 1 1 1\n\n";
    exit;
}

if ($peak_pos_as_input > $number_chr_bins - int($graph_length/2 + 1) ) {
    $temp_var=$number_chr_bins - int($graph_length/2 + 1);
    print "\nFATAL ERROR: Graph Center ($peak_pos_as_input) is too close to end of chromosome\n";
    print "    must be equal or smaller than: $temp_var\n\n"; 
        print "usage: plot_sigma_values_EUseq_v1.pl  max(gm/lm/ma)  chrN  graph_width(odd)  graph_center  value_from_file_1 _2 _3 _4  value_scale_1 _2 _3 _4\n";
        print "example usage: plot_sigma_values_EUseq_v1.pl    gm  chr7  701  500    2 2 2 2     1 1 1 1\n\n";
    exit;
}
#
# input sample numbers to be plotted and sample scale values
#
if ($#ARGV==3+$file_number*2) {
    for ($loopf=1; $loopf<=$file_number; $loopf++) {
        $sample_number_f[$loopf]=$ARGV[3+$loopf];
        $adjust_height_f[$loopf]=$ARGV[3+$file_number+$loopf];
    }
} else {
    print "FATAL ERROR: Number of files as specified in script (\$file_number) does not match number of variables in command line\n\n";
        print "usage: plot_sigma_values_EUseq_v1.pl  max(gm/lm/ma)  chrN  graph_width(odd)  graph_center  value_from_file_1 _2 _3 _4  value_scale_1 _2 _3 _4\n";
        print "example usage: plot_sigma_values_EUseq_v1.pl    gm  chr7  701  500    2 2 2 2     1 1 1 1\n\n";
    exit;
}
#
#
# make graph file name
#
$graphname = "Graph";
#
for ($loopf=1; $loopf<=$file_number; $loopf++) {
    $graphname=join("_",$graphname,$sample_name_f[$loopf]);
}
#
$graphname=join("_",$graphname,"bin-size",$bin_size_f[1],$chromosome,$peak_pos_as_input,$graph_length,"sn");
#
for ($loopf=1; $loopf<=$file_number; $loopf++) {
    $graphname=join("_",$graphname,$sample_number_f[$loopf]);
}
#
$graphname=join("_",$graphname,"ah");
#
for ($loopf=1; $loopf<=$file_number; $loopf++) {
    $graphname=join("_",$graphname,$adjust_height_f[$loopf]);
}
#
$graphname=join("",$graphname,".png");
#
#
#
#
if ($bin_size==10000) {
    $geneD_replT_file_Name="GeneD_OiRD_ReplT_interpolated__bin-size_10000_chr1-X_0b.csv";
    $pklist_file_Name="Origin_List_bin-size_10000_Table_S1.csv";
} else {
    $geneD_replT_file_Name="empty";
    $pklist_file_Name="empty";
} 
#
#
#
print "\nGenome Annotation file:  $geneD_replT_file_Name\n\n";
print   "Origin list file:        $pklist_file_Name\n\n\n";
#
#
print "Plotted chromosome:                                  chr$chr_number\n";
print "Graph Center (Number of Bins from chromosome start): $peak_pos_as_input\n";
print "Graph Width (Number of Bins plotted):                $graph_length\n";
#
if ($maximum_flag eq "gm") {
    print "Maximum y scale: set automatically based on global (whole genome) maximum\n\n";
} elsif ($maximum_flag eq "lm") {
    print "Maximum y scale: set automatically based on local (plotted region) maximum\n\n";
} elsif ($maximum_flag eq "ma") {
    print "Maximum y scale: set manually at                     $manual_max\n\n";
}
#
#
# reads csv file lines and puts them in variable line_Data
#
#
for ($loopf=1; $loopf<=$file_number; $loopf++) {
    @csv_Data=();
    open FILE, $csv_file_Name[$loopf] or die "Can't open input file: $:\n";
    while ( <FILE> ) {
        chomp; #remove newline
        @line = split(",",$_); # split each line
        if ($#line>0) {
            push(@csv_Data,$_);
        }
    }
    close FILE;
    for ($loopA=0; $loopA<=$#csv_Data; $loopA++) {
        $csv_Data_f[$loopf][$loopA]=$csv_Data[$loopA];
    }
    $number_csv_lines_f[$loopf]=$#csv_Data+1;
}
#
#
@replT_Data=();
if ($geneD_replT_file_Name eq "empty" || !-r "$geneD_replT_file_Name") {
    $number_replT_lines=0;
} else {
    open FILE, $geneD_replT_file_Name;
    while ( <FILE> ) {
        chomp; #remove newline
        @line = split(",",$_); # split each line
        if ($#line==136) {
            push(@replT_Data,$_);
        }
    }
    close FILE;
    $number_replT_lines=$#replT_Data + 1;
}
#
#
@pklist_Data=();
if ($pklist_file_Name eq "empty" || !-r "$pklist_file_Name") {
    $number_pklist_lines=0;
} else {
    open FILE, $pklist_file_Name;
    while ( <FILE> ) {
        chomp; #remove newline
        @line = split(",",$_); # split each line
        if ($#line>0) {
            push(@pklist_Data,$_);
        }
    }
    close FILE;
    $number_pklist_lines=$#pklist_Data + 1;
}
#
#
#
print "Bin Size:                               $bin_size\n";
print "Max Number of Bins:                     $max_number_bins\n";
print "Number of csv File Lines:               ";
for ($loopf=1; $loopf<=$file_number; $loopf++) {
    print "$number_csv_lines_f[$loopf] ";
}
print "\n";
print "Number of Genome Annotation File Lines: $number_replT_lines\n";
print "Number of Origin List File Lines:       $number_pklist_lines\n\n";
#
# verification
#
for ($loopf=1; $loopf<=$file_number; $loopf++) {
    if ($number_csv_lines_f[$loopf] != $max_number_bins) {
        print "\n";
        print "Number of csv File Lines not equal to Number of Bins in File Name - Exiting\n\n\n";
        exit;
    }
}
$number_csv_lines=$number_csv_lines_f[1];
#
if ($number_replT_lines != $max_number_bins && $number_replT_lines!=0) {
   print "\n";
   print "Number of Genome Annotation File Lines not equal to Number of Bins in File Name - Exiting\n\n\n";
   exit;
}
#
#
# extract csv data
#
#
for ($loopf=1; $loopf<=$file_number; $loopf++) {
    if ($csv_file_Name[$loopf] =~ /chr1-X_sigma_all_EU_0b.csv/ || $csv_file_Name[$loopf] =~ /chr1-X_sigma_all_EU_0b.csv/) {
        $csv_flag_f[$loopf]="all";
        $csv_var_number_f[$loopf]=14;
        $adjust_position[$loopf]=5;
    } elsif ($csv_file_Name[$loopf] =~ /chr1-X_sigma_select_EU_0b.csv/ || $csv_file_Name[$loopf] =~ /chr1-X_sigma_select_EU_0b.csv/) {
        $csv_flag_f[$loopf]="mbrsm";
        $csv_var_number_f[$loopf]=5;
        $adjust_position[$loopf]=5;
    } else {
        print "\nNot valid csv file name, exiting\n\n";
        exit;
    }
}
#
for ($loopf=1; $loopf<=$file_number; $loopf++) {
    for ($loopA=0; $loopA<$number_csv_lines; $loopA++) {
        @line = split(",",$csv_Data_f[$loopf][$loopA]);
        $handle=($chr_number-1)*($csv_var_number_f[$loopf]+1);
        $pk[$loopf][$loopA] = $line[$handle+$sample_number_f[$loopf]-1];
    }
}
#
# extract adjust values from first csv file
#
for ($loopf=1; $loopf<=1; $loopf++) {
    for ($loopA=0; $loopA<$number_csv_lines; $loopA++) {
        @line = split(",",$csv_Data_f[$loopf][$loopA]);
        $handle=($chr_number-1)*($csv_var_number_f[$loopf]+1);
        $adjust[$loopA] = $line[$handle+$adjust_position[$loopf]-1];
    }
}
#
# find global max for each sample for all chromosomes
#
for ($loopf=1; $loopf<=$file_number; $loopf++) {
    @sample_number_range=();
    for ($loopA=0; $loopA<$number_csv_lines; $loopA++) {
        @line = split(",",$csv_Data_f[$loopf][$loopA]);
        for ($loopC=1; $loopC<=23; $loopC++) {
            $handle=($loopC-1)*($csv_var_number_f[$loopf]+1);
            push(@sample_number_range,$line[$handle+$sample_number_f[$loopf]-1]);
        }
    }
    @sort_sample_number_range=sort {$a <=> $b} @sample_number_range;
    $loopM=$#sort_sample_number_range;
    $global_maximum_1=($sort_sample_number_range[$loopM-25]+$sort_sample_number_range[$loopM-27]+$sort_sample_number_range[$loopM-29]+$sort_sample_number_range[$loopM-31]+$sort_sample_number_range[$loopM-33]+$sort_sample_number_range[$loopM-26]+$sort_sample_number_range[$loopM-28]+$sort_sample_number_range[$loopM-30]+$sort_sample_number_range[$loopM-32]+$sort_sample_number_range[$loopM-34])/20;
    $global_maximum_2=($sort_sample_number_range[$loopM-45]+$sort_sample_number_range[$loopM-47]+$sort_sample_number_range[$loopM-49]+$sort_sample_number_range[$loopM-51]+$sort_sample_number_range[$loopM-53]+$sort_sample_number_range[$loopM-46]+$sort_sample_number_range[$loopM-48]+$sort_sample_number_range[$loopM-50]+$sort_sample_number_range[$loopM-52]+$sort_sample_number_range[$loopM-54])/20;
    $global_maximum_f[$loopf]=$global_maximum_1+$global_maximum_2;
}
#
#
# extract Genome Annotation data 
#
if ($number_replT_lines==$max_number_bins) {
    for ($loopA=0; $loopA<$number_replT_lines; $loopA++){
        @line = split(",",$replT_Data[$loopA]);
        $handle=($chr_number-1)*6;
        $replT[$loopA] = $line[$handle+0];
        $genic[$loopA] = $line[$handle+2];
        $intergen[$loopA] = $line[$handle+3];
        $gene_name[$loopA] = $line[$handle+4];
    } 
} else {
    $number_replT_lines=$max_number_bins;
    for ($loopA=0; $loopA<$number_replT_lines; $loopA++){
        $replT[$loopA] = "UND";
        $genic[$loopA] = 0;
        $intergen[$loopA] = 0;
        $gene_name[$loopA] = "UND";
    } 
}
#
#
$mstartpos=$peak_position - (($graph_length-1)/2);
$mendpos=  $peak_position + (($graph_length-1)/2);
#
#
# extract origin data from PKlist file
#
if ($pklist_file_Name eq "Origin_List_bin-size_10000_Table_S1.csv") {
    $chr_line_in_file=1;
    $pos_line_in_file=2;
    $pk_type_in_file=3;
} else {
    $chr_line_in_file=0;
    $pos_line_in_file=0;
    $pk_type_in_file=0;
}
#
$count_peak=0;
if ($number_pklist_lines>0 && $chr_line_in_file==1) {
    for ($loopA=0; $loopA<$number_pklist_lines; $loopA++){
        @line = split(",",$pklist_Data[$loopA]);
        if ($line[$chr_line_in_file]==$chr_number) {
            $pklist_pos[$count_peak] = $line[$pos_line_in_file];
            $pklist_type[$count_peak] = $line[$pk_type_in_file];
            $count_peak++;
        }
    }
    $number_pklist_lines=$count_peak;
    $count_peak--;
} else {
    $number_pklist_lines=0;
}
#
#
#
#
# get peak data (csv file data and Genome Annotation data)
#
for ($loopf=1; $loopf<=$file_number; $loopf++) {
    for ($loopB=1; $loopB<=$graph_length+1; $loopB++) {                  
       $pos_csv = $peak_position - (($graph_length-1)/2+1) + $loopB;
       #print "$pos_csv\n";
       $mpk[$loopf][$loopB] = $pk[$loopf][$pos_csv];
    }
}
#
for ($loopB=1; $loopB<=$graph_length+1; $loopB++) {
       $pos_csv = $peak_position - (($graph_length-1)/2+1) + $loopB;
       $mgenic[$loopB]=$genic[$pos_csv];
       $mintergen[$loopB]=$intergen[$pos_csv];
       $mgene_name[$loopB]=$gene_name[$pos_csv];
       $mreplT[$loopB]=$replT[$pos_csv];
       $madjust[$loopB]=$adjust[$pos_csv];
}
#
#
#
# adjust height of sample_number_1 and sample_number_2
#
for ($loopf=1; $loopf<=$file_number; $loopf++) {
    if ($adjust_height_f[$loopf]!=1) {
        for ($loopB=1; $loopB<=$graph_length+1; $loopB++) {
            $mpk[$loopf][$loopB]=$mpk[$loopf][$loopB]*$adjust_height_f[$loopf];
        }
    }
}
#
# find local maximum height value
#
$max=0;
#
for ($loopf=1; $loopf<=$file_number; $loopf++) {
     for ($loopB=1; $loopB<=$graph_length+1; $loopB++) {
         if ($mpk[$loopf][$loopB] > $max) {$max = $mpk[$loopf][$loopB]}  
     }
}
#
for ($loopf=1; $loopf<=$file_number; $loopf++) {
    print "Global maximum sample $loopf:  $global_maximum_f[$loopf]\n";
}
print "Local maximum:            $max\n";
$local_maximum=$max;
#
if ($maximum_flag eq "gm") { 
    for ($loopf=1; $loopf<=$file_number; $loopf++) {
        if ($global_maximum_f[$loopf]>=$max) {$max=$global_maximum_f[$loopf]}
    }
}
#
if ($max==$local_maximum) {
    print "    WARNING: local maximum GREATER than global maximum";
    if ($maximum_flag ne "ma") {print ",  using local maximum\n"} else {print "\n"}
}
#
if ($maximum_flag ne "ma") {
    $max=int($max*1.1);
    print "Used maximum:             $max\n\n";
} else {
    $max=$manual_max;
    print "Used manual maximum:      $max\n\n";
}
#
#
# suggest scale values based on global max values
#
print "Suggested scaling for files based on global maxima (to input in command line):  ";
for ($loopf=1; $loopf<=$file_number; $loopf++) {
    $sugg_scale=int($global_maximum_f[$file_number]/$global_maximum_f[$loopf]*100+0.5)/100;
    print "$sugg_scale  ";
}
print "\n\n";
#
# finds height values used to plot the horizontal ticks for each sample
#
if ($draw_horizontal_ticks==1) {
    for ($loopf=1; $loopf<=$file_number; $loopf++) {
        $max_f[$loopf]=int($max/$adjust_height_f[$loopf]);
        @split_max_int=split("",$max_f[$loopf]);
        $max_digits=$#split_max_int;
        $max_division=10**($max_digits);
        $max_f[$loopf]=int($max_f[$loopf]/$max_division)*$max_division;
        print "Value for horizontal tick sample $loopf:  $max_f[$loopf]\n";
        $height_max_f[$loopf]=$max_f[$loopf]*$adjust_height_f[$loopf];
    }
    print "\n";
}
#
# find how big the max value is (and multiply all values by 1000 if max value is less than 1000)
#    needed later on, to order  samples  based on peak height  and  to have smooth peaks
#
@split_max_int=split("",$max);
$max_digits=$#split_max_int+1;
$sample_multipl=1;
if ($max_digits<4) {  # for single digit log samples with 3 decimals
    $sample_multipl=1000;
    $max_digits=$max_digits+3;
}
$max_addition=10**($max_digits+3);  #the additional +3 is to allow characters for the  file  number
#
#
# prepare colors for peaks
#
#primary colors
$file_number_OE=int($file_number/2);
$file_number_NE=$file_number-$file_number_OE;
#
if ($file_number_NE!=2 && $file_number_OE!=2) {
        print "\nFATAL ERROR:  number of files to plot must be equal to 4\n\n";
        print "usage: plot_sigma_values_EUseq_v1.pl  max(gm/lm/ma)  chrN  graph_width(odd)  graph_center  value_from_file_1 _2 _3 _4  value_scale_1 _2 _3 _4\n";
        print "example usage: plot_sigma_values_EUseq_v1.pl    gm  chr7  701  500    2 2 2 2     1 1 1 1\n\n";
        exit;
}
#
# primary colors for   nascent_EU   data
#
$colorHexPRGB[1]="#555555"; #50 255 200
$colorHexPRGB[2]="#555555"; #255 100 150
$colorHexPRGB[3]="#AAAAAA"; #170 170 170
$colorHexPRGB[4]="#AAAAAA";
#
#merge colors
#
# calculated later
#
#
#
#
$stroke = 6;                    
$width = $graph_length*2+12;  # (501*2 + 12) graph width in pixel - 840 for square graphs - 1260 for non-square graphs
$height = 523; # graph height in pixel (for lines 1100; for bars 560) - affects plot
#
if ($draw_horizontal_ticks==1) {
    $graph_displacement=8; 
} else {
    $graph_displacement=0; 
}
#
my $graphname  = $graphname;
my $graph      = Imager->new(xsize=>$width, ysize=>$height);
my $canvas     = Imager->new(xsize=>$width+$graph_displacement, ysize=>$height);
#
# draw the canvas
$canvas->box(filled=>1, color=>'#FFFFFF');
# draw the graph
$graph->box(filled=>1, color=>'#000000');
$graph->box(filled=>1, color=>'#FFFFFF',xmin=>$stroke, ymin=>$stroke, xmax=>($width-$stroke-1), ymax=>($height-$stroke-1));
#
#
$graph->box(filled =>1,  #horizontal line separating peaks from genes
                 color  => '#000000',
                 xmin   => 6, 
                 ymin   => $height-$stroke-72, 
                 xmax   => $graph_length*2+6, 
                 ymax   => $height-$stroke-67
);
$graph->box(filled =>1,  #horizontal line separating peaks from replT
                 color  => '#000000',
                 xmin   => 6, 
                 ymin   => 40, 
                 xmax   => $graph_length*2+6, 
                 ymax   => 45
);
#
# print marks for 0.1,0.2, etc Mb
#
for ($loopB=1; $loopB<=$graph_length+1; $loopB++) {
       $pos_csv = $peak_position - (($graph_length-1)/2+1)  + $loopB;
       $div_csv=$pos_csv/10;
       if ($div_csv==int($div_csv)) {
                    $graph->box(filled => 1,
                                color  => '#FFFFFF',
                                xmin   => $stroke -1 + ($loopB-1)*2, 
                                ymin   => $height-$stroke-72, 
                                xmax   => $stroke + 2 + ($loopB-1)*2, 
                                ymax   => $height-$stroke-67
                                );
                    $graph->box(filled => 1,
                                color  => '#FFFFFF',
                                xmin   => $stroke -1 + ($loopB-1)*2, 
                                ymin   => 40, 
                                xmax   => $stroke + 2 + ($loopB-1)*2, 
                                ymax   => 45
                                );
    }
}
#
# print peaks (main positions)
#
for ( $loopB=1; $loopB<=$graph_length; $loopB++ ) {
    # order peaks based on height
    @peak_heights_codes=();
    for ($loopf=1; $loopf<=$file_number; $loopf++) {
        $peak_height_code=$max_addition+int($mpk[$loopf][$loopB]*$sample_multipl)*1000+$loopf;
        #print "$mpk[$loopf][$loopB]   $peak_height_code\n";
        push(@peak_heights_codes,$peak_height_code);
    }
    @sort_peak_heights_codes=sort {$b <=> $a} @peak_heights_codes;
    for ($loopg=1; $loopg<=$file_number; $loopg++) {
        $subtr=int($sort_peak_heights_codes[$loopg-1]/1000)*1000;  # all info except $loopf; used to get $loopf value
        $graph_order[$loopg]=$sort_peak_heights_codes[$loopg-1]-$subtr;  # get $loopf value
        #print "$graph_order[$loopg]  ";
    }
    #
    #
    # draw tallest sample
    $loopf=$graph_order[1];
    $tallest_sample[$loopB]=$loopf;
        #
        $graph->box(filled => 1,
                color  => $colorHexPRGB[$loopf],
                xmin   => $stroke + 0 + ($loopB-1)*2, 
                ymin   => $height-($mpk[$loopf][$loopB]*($height-$stroke-113)/$max)-$stroke-73, 
                xmax   => $stroke + 0 + ($loopB-1)*2, 
                ymax   => $height-$stroke-73 );
    # draw other samples
    for ($loopg=2; $loopg<=$file_number; $loopg++) {
        # get color
        # merge colors
        #
        $loopf=$graph_order[$loopg];
        #
        if ($loopg==2) {
            if ( ($graph_order[1]==1 && $graph_order[2]==3) || ($graph_order[1]==3 && $graph_order[2]==1) ) {
                $colorHexMergeRGB="#157910";
            } elsif ( ($graph_order[1]==2 && $graph_order[2]==4) || ($graph_order[1]==4 && $graph_order[2]==2) ) {
                $colorHexMergeRGB="#B40000";
            } else { $colorHexMergeRGB="#99A400" }
        }
        if ($loopg>2) { $colorHexMergeRGB="#99A400" }
        #
        $graph->box(filled => 1,
                color  => $colorHexMergeRGB,
                xmin   => $stroke + 0 + ($loopB-1)*2, 
                ymin   => $height-($mpk[$loopf][$loopB]*($height-$stroke-113)/$max)-$stroke-73, 
                xmax   => $stroke + 0 + ($loopB-1)*2, 
                ymax   => $height-$stroke-73 );
    } 
}
#
#
#
#
# print peaks (interim positions)
#
for ( $loopB=1; $loopB<=$graph_length; $loopB++ ) {
    # order peaks based on height
    @peak_heights_codes=();
    for ($loopf=1; $loopf<=$file_number; $loopf++) {
        if ($madjust[$loopB]==0) {
            $ymin_average=0;
        } elsif ($madjust[$loopB+1]==0) {
            $ymin_average=$mpk[$loopf][$loopB];
        } else {
            $ymin_average=($mpk[$loopf][$loopB]+$mpk[$loopf][$loopB+1])/2;    
        }
        $peak_height_code=$max_addition+int($ymin_average*$sample_multipl)*1000+$loopf;
        #print "$mpk[$loopf][$loopB]   $peak_height_code\n";
        push(@peak_heights_codes,$peak_height_code);
    }
    @sort_peak_heights_codes=sort {$b <=> $a} @peak_heights_codes;
    for ($loopg=1; $loopg<=$file_number; $loopg++) {
        $subtr=int($sort_peak_heights_codes[$loopg-1]/1000)*1000;  # all info except $loopf; used to get $loopf value
        $graph_order[$loopg]=$sort_peak_heights_codes[$loopg-1]-$subtr;  # get $loopf value
        #print "$graph_order[$loopg]  ";
    }
    #
    #
    # draw tallest sample
    $loopf=$graph_order[1];
    $tallest_sample[$loopB]=$loopf;
        #
        if ($madjust[$loopB]==0) {
            $ymin_average=0;
        } elsif ($madjust[$loopB+1]==0) {
            $ymin_average=$mpk[$loopf][$loopB];
        } else {
            $ymin_average=($mpk[$loopf][$loopB]+$mpk[$loopf][$loopB+1])/2;    
        }
        #
        $graph->box(filled => 1,
                color  => $colorHexPRGB[$loopf],
                xmin   => $stroke + 1 + ($loopB-1)*2, 
                ymin   => $height-($ymin_average*($height-$stroke-113)/$max)-$stroke-73, 
                xmax   => $stroke + 1 + ($loopB-1)*2, 
                ymax   => $height-$stroke-73 );
    # draw other samples
    for ($loopg=2; $loopg<=$file_number; $loopg++) {
        # get color
        #merge colors
        #
        #
        $loopf=$graph_order[$loopg];
        #
        if ($loopg==2) {
            if      ( ($graph_order[1]==1 && $graph_order[2]==3) || ($graph_order[1]==3 && $graph_order[2]==1) ) {
                $colorHexMergeRGB="#157910";
            } elsif ( ($graph_order[1]==2 && $graph_order[2]==4) || ($graph_order[1]==4 && $graph_order[2]==2) ) {
                $colorHexMergeRGB="#B40000";
            } else { $colorHexMergeRGB="#99A400" }
        }
        if ($loopg>2) { $colorHexMergeRGB="#99A400" }
        #
        if ($madjust[$loopB]==0) {
            $ymin_average=0;
        } elsif ($madjust[$loopB+1]==0) {
            $ymin_average=$mpk[$loopf][$loopB];
        } else {
            $ymin_average=($mpk[$loopf][$loopB]+$mpk[$loopf][$loopB+1])/2;    
        }
        #
        $graph->box(filled => 1,
                color  => $colorHexMergeRGB,
                xmin   => $stroke + 1 + ($loopB-1)*2, 
                ymin   => $height-($ymin_average*($height-$stroke-113)/$max)-$stroke-73, 
                xmax   => $stroke + 1 + ($loopB-1)*2, 
                ymax   => $height-$stroke-73 );
    } 
}
#
#
# print gene annotation based on refseq gene direction 
#
for ( $loopB=1; $loopB<=$graph_length; $loopB++ ) {
    #define color
    #
    $color_plot_gen="#99A400";
    if ($mgene_name[$loopB] =~ ";f" && $mgene_name[$loopB] !~ ";r") {
        $colorR=50;
        $colorhexR=uc(sprintf("%x", $colorR));
        #
        $colorG=170;
        $colorhexG=uc(sprintf("%x", $colorG));
        #
        $colorB=16;
        $colorhexB=uc(sprintf("%x", $colorB));
        #
        $color_plot_gen=join("","#",$colorhexR,$colorhexG,$colorhexB);   # color = #32AA10
    } elsif ($mgene_name[$loopB] =~ ";r" && $mgene_name[$loopB] !~ ";f") {
        $colorR=170;
        $colorhexR=uc(sprintf("%x", $colorR));
        #
        $colorG=50;
        $colorhexG=uc(sprintf("%x", $colorG));
        #
        $colorB=50;
        $colorhexB=uc(sprintf("%x", $colorB));
        #
        $color_plot_gen=join("","#",$colorhexR,$colorhexG,$colorhexB);   # color = #AA3232
    }
    if ($mgenic[$loopB]<-60) {$color_plot_gen="#220055"}
    #
    if ($mintergen[$loopB]==-200 ) {
        $color_plot_ige="#AAAAAA";
    } else {
        $color_plot_ige="#333333";
    }
    #
    #
    if ($mgenic[$loopB]<=-50) {
                    $graph->box(filled =>1,
                                color  => $color_plot_gen,
                                xmin   => $stroke + 0 + ($loopB-1)*2, 
                                ymin   => $height-$stroke-66, 
                                xmax   => $stroke + 1 + ($loopB-1)*2, 
                                ymax   => $height-$stroke-34
                                );
    }
    #
    if ($mintergen[$loopB]<=-200 ) {
                    $graph->box(filled =>1,
                                color  => $color_plot_ige,
                                xmin   => $stroke + 0 + ($loopB-1)*2, 
                                ymin   => $height-$stroke-33, 
                                xmax   => $stroke + 1 + ($loopB-1)*2, 
                                ymax   => $height-$stroke-1
                                );
    }
}
#
# print replication timing domains
#
$few_colors_flag=1;
for ( $loopB=1; $loopB<=$graph_length; $loopB++ ) {
    #
    if ($few_colors_flag==1) {
      if ($mreplT[$loopB] eq "eSC") {
        $color_replT = "#3664CC";
      } elsif ($mreplT[$loopB] eq "eSU") {
        $color_replT = "#3664CC";
      } elsif ($mreplT[$loopB] eq "mSC") {
        $color_replT = "#32AA10";
      } elsif ($mreplT[$loopB] eq "mSU") {
        $color_replT = "#32AA10";
      } elsif ($mreplT[$loopB] eq "lS") {
        $color_replT = "#F2F26B";
      } else {
        $color_replT = "#FFFFFF";
      }
    } else {
      if ($mreplT[$loopB] eq "eSC") {
        $color_replT = "#3664CC";
      } elsif ($mreplT[$loopB] eq "eSU") {
        $color_replT = "#6BCCCC";
      } elsif ($mreplT[$loopB] eq "mSC") {
        $color_replT = "#32AA10";
      } elsif ($mreplT[$loopB] eq "mSU") {
        $color_replT = "#F2F26B";
      } elsif ($mreplT[$loopB] eq "lS") {
        $color_replT = "#99A400";
      } else {
        $color_replT = "#FFFFFF";
      }
    }
    #
    $graph->box(filled =>1,
                color  => $color_replT,
                xmin   => $stroke + 0 + ($loopB-1)*2, 
                ymin   => $stroke,
                xmax   => $stroke + 1 + ($loopB-1)*2, 
                ymax   => 39
                );
}
#
#
# print pklist (origins) positions (color blue) - also draws tick just above genes 
#
if ($show_origins eq "yes") {
    $loopA_stop=$number_pklist_lines;
} else {
    $loopA_stop=-1;
}
for ($loopA=0; $loopA<$loopA_stop; $loopA++){
    if ($pklist_pos[$loopA] > $mstartpos && $pklist_pos[$loopA] < $mendpos) {
       if ($pklist_type[$loopA] eq "Oi") {$color_peak="#FE2B2B"} else {$color_peak="#7F497F"}
       if ($pklist_type[$loopA] eq "Oi") {$color_peak_2="#FE2B2B"} else {$color_peak_2="#7F497F"}
       if ($pklist_type[$loopA] eq "Oi2") {$color_peak="#FF8585"} 
       if ($pklist_type[$loopA] eq "Oi2") {$color_peak_2="#FF8585"} 
       $loopB=$pklist_pos[$loopA]-$mstartpos+1;
       $loopf=$tallest_sample[$loopB];
       $heighest_peak=$mpk[$loopf][$loopB];
       for ($loopfp=1; $loopfp<=$file_number; $loopfp++) {
           if ($mpk[$loopfp][$loopB+1]>$heighest_peak) {$heighest_peak=$mpk[$loopfp][$loopB+1]}
           if ($mpk[$loopfp][$loopB-1]>$heighest_peak) {$heighest_peak=$mpk[$loopfp][$loopB-1]}
       }
                    $graph->box(filled =>1,
                                color  => $color_peak,
                                xmin   => $stroke + 0 + ($loopB-1)*2, 
                                ymin   => $stroke+43, 
                                xmax   => $stroke + 1 + ($loopB-1)*2, 
                                ymax   => $height-($heighest_peak*($height-$stroke-113)/$max)-$stroke-130
                                );
                    $graph->box(filled =>1,
                                color  => "#DDDDDD",
                                xmin   => $stroke + 0 + ($loopB-1)*2, 
                                ymin   => $stroke, 
                                xmax   => $stroke + 1 + ($loopB-1)*2, 
                                ymax   => $stroke+39
                                );
    }
}
#
#
# draw horizontal ticks 
#
#$height_max_f[2]=$height_max_f[2]*2/3;
if ($draw_horizontal_ticks==1) {
    $canvas->box(filled => 1,
             color  => "#000000",
             xmin   => 0, 
             ymin   => $height-$stroke-73, 
             xmax   => $graph_displacement, 
             ymax   => $height-73 );
    #
    for ($loopf=$file_number; $loopf>=1; $loopf--) {
        $canvas->box(filled => 1,
                 color  => $colorHexPRGB[$loopf],
                 xmin   => 0, 
                 ymin   => $height-($height_max_f[$loopf]*($height-$stroke-113)/$max)-$stroke-73,  
                 xmax   => $graph_displacement, 
                 ymax   => $height-($height_max_f[$loopf]*($height-$stroke-113)/$max)-73 );
    }
    #
    for ($loopf=$file_number; $loopf>=1; $loopf--) {
        $graph->box(filled => 1,
                color  => $colorHexPRGB[$loopf],
                xmin   => 0, 
                ymin   => $height-($height_max_f[$loopf]*($height-$stroke-113)/$max)-$stroke-73,  
                xmax   => $stroke-1, 
                ymax   => $height-($height_max_f[$loopf]*($height-$stroke-113)/$max)-73 );
    }
}
#
#            
$canvas->paste(left=>$graph_displacement, top=>0, src=>$graph);
#
$canvas->write(file=>$graphname, type=>'png') or die $graph->errstr;
#
#
#
print "\nName of output image file:   $graphname\n\n\n";
system "display $graphname &";
#
#
#
exit;
#
#
#


