#!/usr/bin/perl -w
#
#
# 
#  script: calculate_sigma_from_number_hits_per_bin_v1.pl
#  
#  published in: Macheret M., and Halazonetis, T.D.
#                Intragenic origins due to short G1 phases underlie oncogene-induced DNA replication stress.
#                Nature 2018.
#
#  disclaimers: no claims are made that this script performs any specific task
#               not responsible for any damage/loss caused by using this script
#               script is to be used only for research purposes
#               
#  prerequisites: good knowledge of linux and perl are required to run this script
#                 no support can be provided to troubleshoot this script
#                 if you have difficulties, please contact your local linux/perl expert
#
#  IMPORTANT: works with the masked human genome assembly: GRCh37/hg19
#             the sam files must be aligned to the above assembly 
#
#  copyright (2017): Thanos D. Halazonetis, University of Geneva
#
#  
#
#
#  usage: calculate_sigma_from_number_hits_per_bin_v1.pl    repl_file_chr1-X_adjbin_0b.csv
#
#  requires in same directory: "adjbin_0b.csv" and matching "adjbin_qual_counts_0b.txt" files
#      generated by script: calculate_number_hits_per_bin_v1.pl
#
#
#
#
#
#
#
# DATA PLOTTED IN OUTPUT FILES
#
#
# FILE: -------_sigma_select_0b.csv
#
# for each genomic bin:
#
# 1 = $sigma_bin_mb_totalSD_sm        sigma value with background (noise) subtraction, all values smoothened
# 2 = $sigma_bin_mb_totalSD_tm        sigma value with background (noise) subtraction, high values trimmed
# 3 = $sigma_bin_totalSD_sm           sigma value without background (noise) subtraction, all values smoothened
# 4 = $sigma_bin_totalSD_tm           sigma value without background (noise) subtraction, high values trimmed
# 5 = $adjust                         sequence coverage of genomic DNA sequencing (reflecting all sequencing biases)  
#
#
# FILE: -------_sigma_all_0b.csv
#
# for each genomic bin:
#
#  1 = $sigma_bin_mb_totalSD_sm        sigma value with background (noise) subtraction, all values smoothened
#  2 = $sigma_bin_mb_totalSD_tm        sigma value with background (noise) subtraction, high values trimmed
#  3 = $sigma_bin_totalSD_sm           sigma value without background (noise) subtraction, all values smoothened
#  4 = $sigma_bin_totalSD_tm           sigma value without background (noise) subtraction, high values trimmed
#  5 = $adjust                         sequence coverage of genomic DNA sequencing (reflecting all sequencing biases)  
#  6 = $sigma_bin_mb_totalSD           sigma value with background (noise) subtraction
#  7 = $sigma_bin_totalSD              sigma value without background (noise) subtraction
#  8 = $sigma_bin_mb_totalSD_log2      sigma value with background (noise) subtraction, converted to log2
#  9 = $sigma_bin_mb_totalSD_sm_log2   sigma value with background (noise) subtraction, all values smoothened, converted to log2
# 10 = $sigma_bin_mb_totalSD_tm_log2   sigma value with background (noise) subtraction, high values trimmed, converted to log2
# 11 = $adjbin                         number of sequences per bin, adjusted for all sequencing biases (using $adjust)
# 12 = $adjbin_mb                      number of sequences per bin with background (noise) subtraction, adjusted for all sequencing biases (using $adjust)
# 13 = $adjbin_SD                      standard deviation of adjbin values
# 14 = $bin                            number of sequences per bin
#
#
# FILE: -------_sigma_qual_counts_0b.txt
#
# statistics indicating the quality of data
#
#
#
#
print "\n";
#
$file_Name=$ARGV[0];
@temp_file_name1=split("adjbin_0b.csv",$file_Name);
$quality_file_Name=join("",$temp_file_name1[0],"adjbin_qual_counts_0b.txt");
#
if ($#ARGV!=0) {
    print "\nusage: calculate_sigma_from_number_hits_per_bin_v1.pl    repl_file_chr1-X_adjbin_0b.csv\n";
    print "need to provide file name\n\n";
    exit;
}
#
if (!-r "$file_Name" ) {
    print "\nusage: calculate_sigma_from_number_hits_per_bin_v1.pl    repl_file_chr1-X_adjbin_0b.csv\n";
    print "file type:  repl_file_chr1-X_adjbin_0b.csv   non-existent or not readable\n\n";
    exit;
}
#
if (!-r "$quality_file_Name" ) {
    print "\nusage: calculate_sigma_from_number_hits_per_bin_v1.pl    repl_file_chr1-X_adjbin_0b.csv\n";
    print "program requires file type:    repl_file_chr1-X_adjbin_qual_counts_0b.txt    in the same directory\n";
    print "file:    $quality_file_Name   non-existent or not readable\n\n";
    exit;
}
#
# get correction factor, total sample hits, total adjust hits
#
$get_correction_factor=`grep "Correction factor" $quality_file_Name`;
@temp_correction_factor=split(" ",$get_correction_factor);
$Acorr_factor=$temp_correction_factor[2];
#
$get_total_sample_hits=`grep "Total sample hits" $quality_file_Name`;
@temp_total_sample_hits=split(" ",$get_total_sample_hits);
$bin_total_hits=$temp_total_sample_hits[3];
#
$get_total_adjust_hits=`grep "Adjust total hits" $quality_file_Name`;
@temp_total_adjust_hits=split(" ",$get_total_adjust_hits);
$adjust_total_hits=$temp_total_adjust_hits[3];
#
# get bin size
#
@temp_bin_size_1=split("bin-size_",$file_Name);
@temp_bin_size_2=split("_",$temp_bin_size_1[1]);
$bin_size=$temp_bin_size_2[0];
$max_chr_size=250000000;
$max_number_bins=$max_chr_size/$bin_size;
print "\nFile Name: $file_Name\n";
print "Bin size: $bin_size\n";
print "Max number of bins: $max_number_bins\n";
print "Total sample hits: $bin_total_hits\n";
print "Total adjust hits: $adjust_total_hits\n";
print "Correction factor from bin to adjbin: $Acorr_factor\n\n\n";
$donothing=0;
#
# define variables; mb: minus mean baseline
#
for ($loopA=0; $loopA<=$max_number_bins; $loopA++) {
   for ($loopC=1; $loopC<=23; $loopC++) {
      #
      $bin[$loopC][$loopA] = 0;                            # actual counts
      #
      $adjbin[$loopC][$loopA] = 0;                         # adjusted bin (adjbin)
      $adjbin_mb[$loopC][$loopA] = 0;                      # adjusted bin minus baseline mean
      $adjbin_SD[$loopC][$loopA]=0;                        # SD of adjbin
      #
      $sigma_bin_totalSD[$loopC][$loopA]=0;
      $sigma_bin_totalSD_sm[$loopC][$loopA]=0;
      $sigma_bin_totalSD_tm[$loopC][$loopA]=0;
      $sigma_bin_mb_totalSD[$loopC][$loopA]=0;
      $sigma_bin_mb_totalSD_sm[$loopC][$loopA]=0;           
      $sigma_bin_mb_totalSD_tm[$loopC][$loopA]=0; 
      #
      $sigma_bin_mb_totalSD_log2[$loopC][$loopA]=0;             
      $sigma_bin_mb_totalSD_sm_log2[$loopC][$loopA]=0;           
      $sigma_bin_mb_totalSD_tm_log2[$loopC][$loopA]=0; 
      #
      $adjust[$loopC][$loopA] = 0;
      #
   }
}
#
#
# reads lines and puts them in variable line_Data
#
#
open FILE, $file_Name or die "Can't open input file: $:\n";
while ( <FILE> ) {
    chomp; #remove newline
    @line = split(",",$_); # split each line
    if ($#line>0) {
    push(@csv_Data,$_);
    }
}
close FILE;
#
# extract data 
#
for ($loopA=0; $loopA<=$max_number_bins; $loopA++) {
   @line = split(",",$csv_Data[$loopA]);
   for ($loopC=1; $loopC<=23; $loopC++) {
      $handle=($loopC-1)*4;
      $bin[$loopC][$loopA] = $line[$handle];        # original counts
      $adjbin[$loopC][$loopA] = $line[$handle+1];   # original counts divided by adjust and scaled
      $adjust[$loopC][$loopA] = $line[$handle+2];   # adjust counts
   }
}
#
# specify chr_size
#
$chr_size[1]=250000000/$bin_size;
$chr_size[2]=244000000/$bin_size;
$chr_size[3]=199000000/$bin_size;
$chr_size[4]=192000000/$bin_size;
$chr_size[5]=181000000/$bin_size;
$chr_size[6]=172000000/$bin_size;
$chr_size[7]=160000000/$bin_size;
$chr_size[8]=147000000/$bin_size;
$chr_size[9]=142000000/$bin_size;
$chr_size[10]=136000000/$bin_size;
$chr_size[11]=136000000/$bin_size;
$chr_size[12]=134000000/$bin_size;
$chr_size[13]=116000000/$bin_size;
$chr_size[14]=108000000/$bin_size;
$chr_size[15]=103000000/$bin_size;
$chr_size[16]=91000000/$bin_size;
$chr_size[17]=82000000/$bin_size;
$chr_size[18]=79000000/$bin_size;
$chr_size[19]=60000000/$bin_size;
$chr_size[20]=64000000/$bin_size;
$chr_size[21]=49000000/$bin_size;
$chr_size[22]=52000000/$bin_size;
$chr_size[23]=156000000/$bin_size;
#
# recalculate adjbin so it is not integer 
#
for ($loopC=1; $loopC<=23; $loopC++) {
    for ($loopA=0; $loopA<$chr_size[$loopC]; $loopA++){
        if ($adjust[$loopC][$loopA]!=0) {  
            $adjbin_2[$loopC][$loopA]=$bin[$loopC][$loopA]*$Acorr_factor*1000/$adjust[$loopC][$loopA];
            if ( abs($adjbin_2[$loopC][$loopA]-$adjbin[$loopC][$loopA]) > 1 ) {
                print "Error:\n";
                print "$file_Name  and\n";
                print "$quality_file_Name\n";
                print "are not from the same dataset\n\n";
            }
            $adjbin[$loopC][$loopA]=$adjbin_2[$loopC][$loopA];
        } else {
            $adjbin[$loopC][$loopA]=0;
        }
    }
}
#
# perform some file validation
#
$bin_recalc_total_hits=0;
$adjust_recalc_total_hits=0;
for ($loopC=1; $loopC<=23; $loopC++) {
    for ($loopA=0; $loopA<$chr_size[$loopC]; $loopA++){
        if ($adjust[$loopC][$loopA]!=0) {
            #
            $bin_recalc_total_hits=$bin_recalc_total_hits+$bin[$loopC][$loopA];
            $adjust_recalc_total_hits=$adjust_recalc_total_hits+$adjust[$loopC][$loopA];
            #
        }
    }
}
#
if ($bin_recalc_total_hits!=$bin_total_hits) {
    print "Error:\n";
    print "$file_Name  and\n";
    print "$quality_file_Name\n";
    print "are not from the same dataset\n\n";
    exit;
}
if ($adjust_recalc_total_hits!=$adjust_total_hits) {
    print "Error:\n";
    print "$file_Name  and\n";
    print "$quality_file_Name\n";
    print "are not from the same dataset\n\n";
    exit;
}
#
#
# start calculations to determine background
#
# establish value of adjbin counts that corresponds to background
#
#
@all_non0_adjbin=();
for ($loopC=1; $loopC<=23; $loopC++) {
    for ($loopA=0; $loopA<$chr_size[$loopC]; $loopA++){
        if ($adjust[$loopC][$loopA]!=0 && $adjbin[$loopC][$loopA]>0) {  #eliminates adjbin values = 0 (i.e. no data recorded at that position)
            push(@all_non0_adjbin,$adjbin[$loopC][$loopA]); 
        }
    }
}
#
#
#
# method to calculate background
#    sort all values
#    plot values at every percentage fraction
#      identify the percentage, where there is a significant increase in values
#
# example of representative results:
#
#
# Actual sorted adjbin values from 9-99 percentiles:
# 25 27 29 31 33 34 36 39 41 43 45 47 49 52 54 56 59    (25)
# 61 64 66 69 72 75 78 81 84 87 91 94 98 102 106    (40)
# 110 115 119 124 130 135 141 147 153 160 168 176 184 193 203    (55)
# 213 225 237 250 264 279 296 315 335 357 381 408 437 471 506    (70)
# 546 588 636 688 747 815 890 972 1063 1167 1287 1415 1561 1730 1925    (85)
# 2140 2395 2683 3025 3422 3911 4487 5173 5995 7046 8395 10135 12856 17464    (99)
#
# Actual sorted adjbin values from 5-95 percentiles:
# 17 19 21 23 25 27 29 31 33 34 36 39 41 43 45 47 49    (21)
# 52 54 56 59 61 64 66 69 72 75 78 81 84 87 91    (36)
# 94 98 102 106 110 115 119 124 130 135 141 147 153 160 168    (51)
# 176 184 193 203 213 225 237 250 264 279 296 315 335 357 381    (66)
# 408 437 471 506 546 588 636 688 747 815 890 972 1063 1167 1287    (81)
# 1415 1561 1730 1925 2140 2395 2683 3025 3422 3911 4487 5173 5995 7046    (95)
#
# Difference of sorted adjbin value at percentile x minus at percentile x-4, for percentiles 9-99 (=diff[x]):
# 8 8 8 8 8 8 8 8 8 8 8 8 9 9 9 9 9    (25)
# 9 10 10 10 11 11 11 12 12 13 13 14 14 15 16    (40)
# 16 17 17 18 19 20 21 23 24 25 27 29 31 33 35    (55)
# 38 41 44 47 51 54 59 65 71 77 85 93 102 114 124    (70)
# 137 151 166 183 201 227 253 283 316 352 397 443 498 563 638    (85)
# 725 834 953 1100 1282 1516 1803 2148 2573 3135 3908 4961 6861 10418    (99)
#
# Function to define background: (diff[x]-diff[x-4])/(diff[x]-diff[x-4])/2*100  for percentiles 9-99:
# -0.5 -0.2 -0.2 -0.2 -0.6 0.1 0.5 1.2 1.3 1.5 1.6 1.3 1.9 1.8 2 1.8 1.6    (25)
# 1.8 1.9 2.6 2.9 3.2 3.2 3.1 3 3.1 3.7 3.3 3.5 3.6 3.4 4.3    (40)
# 4.4 4.1 4.2 3.8 4.2 4.9 5.1 5.5 5.5 5.6 5.8 6.1 6.5 6.5 6.8    (55)
# 6.7 7 7.4 7.1 7.5 7 7.1 8 8.2 8.8 9.1 8.8 9 9.6 9.5    (70)
# 9.6 9.6 9.2 9.5 9.4 10 10.5 10.8 11.1 10.8 11.1 11 11.1 11.5 11.6    (85)
# 12.1 12.6 12.9 13.3 13.9 14.5 15.4 16.1 16.7 17.4 18.4 19.8 22.7 26.9    (99)
#
#
#
# sort arrays to find background value for each sample
#
#
print "Step 1: Determine background (noise) adjbin value:\n\n";
#
@sort_all_non0_adjbin = sort { $a <=> $b } @all_non0_adjbin;  
#
# calculates actual values (just to see values)
print "Actual sorted adjbin values from 9-99 percentiles:\n";
for ($loopC=9; $loopC<100; $loopC++) {
    $number_percent_now = int($#sort_all_non0_adjbin*$loopC/100);
    $now=int($sort_all_non0_adjbin[$number_percent_now]);
    $for_print=$now;
    print "$for_print ";
    if ($loopC==25 || $loopC==40 || $loopC==55 || $loopC==70  || $loopC==85  || $loopC==99) {print "   ($loopC)\n"}
}
print "\n";
# calculates actual values at -4 position (just to see values)
print "Actual sorted adjbin values from 5-95 percentiles:\n";
for ($loopC=9; $loopC<100; $loopC++) {
    $number_percent_now = int($#sort_all_non0_adjbin*($loopC-4)/100);
    $now=int($sort_all_non0_adjbin[$number_percent_now]);
    $for_print=$now;
    print "$for_print ";
    if ($loopC==25 || $loopC==40 || $loopC==55 || $loopC==70  || $loopC==85  || $loopC==99) {$loopP=$loopC-4; print "   ($loopP)\n"}
}
print "\n";
# calculates first difference (just to see values)
print "Difference of sorted adjbin value at percentile x minus at percentile x-4, for percentiles 9-99 (=diff[x]):\n";
for ($loopC=9; $loopC<100; $loopC++) {
    $number_percent_pre = int($#sort_all_non0_adjbin*($loopC-4)/100);
    $number_percent_now = int($#sort_all_non0_adjbin*$loopC/100);
    $diff_now=($sort_all_non0_adjbin[$number_percent_now]-$sort_all_non0_adjbin[$number_percent_pre]+0.5);
    $for_print=int($diff_now);
    print "$for_print ";
    if ($loopC==25 || $loopC==40 || $loopC==55 || $loopC==70  || $loopC==85  || $loopC==99) {print "   ($loopC)\n"}
}
print "\n";
#
# calculates function to define background
print "Function to define background: (diff[x]-diff[x-4])/(diff[x]-diff[x-4])/2*100  for percentiles 9-99:\n";
for ($loopC=9; $loopC<100; $loopC++) {
    $number_percent_pre2 = int($#sort_all_non0_adjbin*($loopC-8)/100);
    $number_percent_pre = int($#sort_all_non0_adjbin*($loopC-4)/100);
    $number_percent_now = int($#sort_all_non0_adjbin*$loopC/100);
    $diff_pre=($sort_all_non0_adjbin[$number_percent_pre]-$sort_all_non0_adjbin[$number_percent_pre2]);
    $diff_now=($sort_all_non0_adjbin[$number_percent_now]-$sort_all_non0_adjbin[$number_percent_pre]);
    if ($diff_now+$diff_pre==0) {
        $find_back_sec_diff[$loopC]=0;
    } else {
        $find_back_sec_diff[$loopC]=int(($diff_now-$diff_pre)/($diff_now+$diff_pre)/2*1000+0.5)/10;
    }
    print "$find_back_sec_diff[$loopC] ";
    if ($loopC==25 || $loopC==40 || $loopC==55 || $loopC==70  || $loopC==85  || $loopC==99) {print "   ($loopC)\n"}
}
print "\n";
#
# stringency: avoids artifacts at low loopC or makes sure that slope continues to increase
#   finds range of loopC values to examine for minimum SD
#
$percentile_baseline_cutoff_low=0;
for ($loopC=12; $loopC<90; $loopC++) {
    $mov_ave_find_back_sec_diff_now=$find_back_sec_diff[$loopC-3]+$find_back_sec_diff[$loopC-2]+$find_back_sec_diff[$loopC-1]+$find_back_sec_diff[$loopC];
    $mov_ave_find_back_sec_diff_after=$find_back_sec_diff[$loopC+1]+$find_back_sec_diff[$loopC+2]+$find_back_sec_diff[$loopC+3]+$find_back_sec_diff[$loopC+4];
    if ($mov_ave_find_back_sec_diff_now>=8 && ($loopC>=21 || $mov_ave_find_back_sec_diff_after>=8) ) {
       $percentile_baseline_cutoff_low=$loopC-11;
       print "Percentile at low baseline cutoff: $percentile_baseline_cutoff_low\n";
       $number_percent_now = int($#sort_all_non0_adjbin*($loopC-11)/100);
       $adjbin_baseline_cutoff_low=$sort_all_non0_adjbin[$number_percent_now];
       print "Baseline of adjbin data values at low cutoff: $adjbin_baseline_cutoff_low\n\n";
       $loopC=120;
    }
}
if ($percentile_baseline_cutoff_low==0) {
    print "******** WARNING: FAILED TO FIND baseline_cutoff_low EXITING ************\n\n";
    exit;
}
#
$percentile_baseline_cutoff_high=0;
for ($loopC=12; $loopC<90; $loopC++) {
    $mov_ave_find_back_sec_diff_now=$find_back_sec_diff[$loopC-3]+$find_back_sec_diff[$loopC-2]+$find_back_sec_diff[$loopC-1]+$find_back_sec_diff[$loopC];
    $mov_ave_find_back_sec_diff_after=$find_back_sec_diff[$loopC+1]+$find_back_sec_diff[$loopC+2]+$find_back_sec_diff[$loopC+3]+$find_back_sec_diff[$loopC+4];
    if ($mov_ave_find_back_sec_diff_now>=32 && ($loopC>=41 || $mov_ave_find_back_sec_diff_after>=32) ) {
       $percentile_baseline_cutoff_high=$loopC-11;
       print "Percentile at high baseline cutoff: $percentile_baseline_cutoff_high\n";
       $number_percent_now = int($#sort_all_non0_adjbin*($loopC-11)/100);
       $adjbin_baseline_cutoff_high=$sort_all_non0_adjbin[$number_percent_now];
       print "Baseline of adjbin data values at high cutoff: $adjbin_baseline_cutoff_high\n\n";
       $loopC=120;
    }
}
if ($percentile_baseline_cutoff_high==0) {
    print "******** WARNING: FAILED TO FIND baseline_cutoff_high SAMPLE MAY HAVE NO PEAKS ************\n\n";
    $percentile_baseline_cutoff_high=$percentile_baseline_cutoff_low+20;
    if ($percentile_baseline_cutoff_high>89) {$percentile_baseline_cutoff_high=$percentile_baseline_cutoff_low+1} 
    $adjbin_baseline_cutoff_high=$adjbin_baseline_cutoff_low*1.1;
}
#
# finds point ($loopC) where background mean and median values coincide
#
$min_diff_mean_median=$adjbin_baseline_cutoff_high;
$adjbin_baseline_mean_at_min=0;
$adjbin_baseline_SD_at_min=0;
$used_percentile_baseline_at_min=0;
$nAdjBin_at_min=0;
$adjbin_baseline_cutoff_at_min=0;
$percentile_baseline_cutoff_at_min=0;
#
print "Finds cutoff (=baseline) of adjbin value, below which a genomic bin is considered to be background noise\n";
print "Baseline is within low and high baseline cutoffs and selected when difference between mean and median\n";
print "   baseline values is minimized\n\n";
print "%   Median   Mean   Cutoff   SD_of_mean   %    Diff_mean_median\n";
for ($loopC=$percentile_baseline_cutoff_low; $loopC<=$percentile_baseline_cutoff_high; $loopC++) {  # $percentile_baseline_cutoff_low   is equal to  $loopC-11  above 
    $index_number_for_baseline_cutoff = int($#sort_all_non0_adjbin*$loopC/100);   # called  $number_percent_now  above
    $index_number_for_baseline_median = int($#sort_all_non0_adjbin*$loopC*0.5/100);   
    $adjbin_baseline_median = int($sort_all_non0_adjbin[$index_number_for_baseline_median]*1000+0.5)/1000;
    $adjbin_baseline_cutoff = $sort_all_non0_adjbin[$index_number_for_baseline_cutoff];
    #
    # calculate mean value and SD of all adjbin values that are equal to or below  $adjbin_baseline_cutoff
    #
    $SAdjBin=0;
    $SSAdjBin=0;
    $nAdjBin=0;
    for ($loopD=0; $loopD<=$#sort_all_non0_adjbin; $loopD++) {
        if ($sort_all_non0_adjbin[$loopD]<=$adjbin_baseline_cutoff) {
            $SAdjBin=$SAdjBin+$sort_all_non0_adjbin[$loopD];
            $SSAdjBin=$SSAdjBin+$sort_all_non0_adjbin[$loopD]*$sort_all_non0_adjbin[$loopD];
            $nAdjBin++;
        } else {
            $used_percentile_baseline=int($loopD/$#sort_all_non0_adjbin*100);
            $loopD=$#sort_all_non0_adjbin+100;
        }
    }
    #print "Percentile used to calculate SD of baseline\n (should be equal to percentile at baseline): $used_percentile_baseline\n";
    #
    $adjbin_baseline_mean=int($SAdjBin/$nAdjBin*1000+0.5)/1000;
    $adjbin_baseline_SD=int(sqrt(($SSAdjBin-$SAdjBin*$SAdjBin/$nAdjBin)/($nAdjBin-1))*1000+0.5)/1000;
    #print "Mean baseline of adjbin data values: $adjbin_baseline_mean\n";
    #print "ANOVA-based SD of mean baseline of adjbin data values: $adjbin_baseline_SD\n";
    #print "Number of adjbin data values used to calculate mean and SD: $nAdjBin\n\n\n";
    #
    $diff_median_mean=$adjbin_baseline_median-$adjbin_baseline_mean;
    if ( abs($diff_median_mean)<=$min_diff_mean_median ) {
        $min_diff_mean_median=abs($diff_median_mean);
        $adjbin_baseline_mean_at_min=$adjbin_baseline_mean;
        $adjbin_baseline_SD_at_min=$adjbin_baseline_SD;
        $used_percentile_baseline_at_min=$used_percentile_baseline;
        $nAdjBin_at_min=$nAdjBin;
        $adjbin_baseline_cutoff_at_min=$adjbin_baseline_cutoff;
        $percentile_baseline_cutoff_at_min=$loopC;
    }
    #
    $diff_median_mean=int(($adjbin_baseline_median-$adjbin_baseline_mean)*1000+0.5)/1000;
    $adjbin_baseline_cutoff=int($adjbin_baseline_cutoff*1000+0.5)/1000;
    print "$loopC    ";
    print "$adjbin_baseline_median    ";
    print "$adjbin_baseline_mean    ";
    print "$adjbin_baseline_cutoff    ";
    print "$adjbin_baseline_SD    $used_percentile_baseline    $diff_median_mean\n";
    #
}
#
print "\n";
#
$adjbin_baseline_mean=$adjbin_baseline_mean_at_min;
$adjbin_baseline_SD=$adjbin_baseline_SD_at_min;
$used_percentile_baseline=$used_percentile_baseline_at_min;
$nAdjBin=$nAdjBin_at_min;
$adjbin_baseline_cutoff=$adjbin_baseline_cutoff_at_min;
$percentile_baseline_cutoff=$percentile_baseline_cutoff_at_min;
#
print "Baseline of adjbin data values (cutoff): $adjbin_baseline_cutoff\n";
print "Percentile at baseline: $percentile_baseline_cutoff\n";
print "Percentile used to calculate SD of baseline\n (should be equal to percentile at baseline): $used_percentile_baseline\n";
print "Mean baseline of adjbin data values: $adjbin_baseline_mean\n";
print "ANOVA-based SD of mean baseline of adjbin data values: $adjbin_baseline_SD\n";
print "Number of adjbin data values used to calculate mean and SD: $nAdjBin\n\n";
#
#
#
####### find SD of adjbin noise counts corresponding to different levels of adjust counts
#
#
#
@non0_adjust_noise=();
for ($loopC=1; $loopC<=23; $loopC++) {
    for ($loopA=0; $loopA<$chr_size[$loopC]; $loopA++){
        if ($adjust[$loopC][$loopA]!=0) {
            if ($adjbin[$loopC][$loopA]<=$adjbin_baseline_cutoff) {
                push(@non0_adjust_noise,$adjust[$loopC][$loopA]);
            }
        }
    }
}
#
$number_split_adj_read=200; # how many bins we will split the adjust reads into
#
@sort_non0_adjust_noise=sort { $a <=> $b } @non0_adjust_noise;
for ($loopE=1; $loopE<=$number_split_adj_read; $loopE++) {
    $index=int($#sort_non0_adjust_noise*$loopE/$number_split_adj_read);
    $adjust_limit[$loopE]=$sort_non0_adjust_noise[$index];
    #print "$adjust_limit[$loopE]\n";
}
$adjust_limit[0]=0;
#print "\n";
#
for ($loopE=1; $loopE<=$number_split_adj_read; $loopE++) {
    $index_list[$loopE]=0;
}
#
for ($loopC=1; $loopC<=23; $loopC++) {
    for ($loopA=0; $loopA<$chr_size[$loopC]; $loopA++){
        if ($adjust[$loopC][$loopA]!=0) {
            if ($adjbin[$loopC][$loopA]<=$adjbin_baseline_cutoff) {
                for ($loopE=1; $loopE<=$number_split_adj_read; $loopE++) {
                    if ($adjust[$loopC][$loopA]>$adjust_limit[$loopE-1] && $adjust[$loopC][$loopA]<=$adjust_limit[$loopE]) {
                        $list_adjbin_noise[$loopE][$index_list[$loopE]]=$adjbin[$loopC][$loopA];
                        $index_list[$loopE]++;
                        $loopE=$number_split_adj_read+1;
                    }
                }
            }
        }
    }
}
#
#for ($loopE=1; $loopE<=$number_split_adj_read; $loopE++) {
#    print "$index_list[$loopE]\n";
#}
#print "\n";
#
# calculate mean value and SD of all adjbin values that are equal to or below  $adjbin_baseline_cutoff
#    according to number of adjust reads (adjust reads divided in bins using  $loopE )
#
$start_loopE=1;
for ($loopE=1; $loopE<=$number_split_adj_read; $loopE++) {
    $SAdjBin=0;
    $SSAdjBin=0;
    $nAdjBin=$index_list[$loopE];
    for ($loopD=0; $loopD<$index_list[$loopE]; $loopD++) {
            $SAdjBin=$SAdjBin+$list_adjbin_noise[$loopE][$loopD];
            $SSAdjBin=$SSAdjBin+$list_adjbin_noise[$loopE][$loopD]*$list_adjbin_noise[$loopE][$loopD];
    }
    #
    if ($nAdjBin==0 || $nAdjBin==1) {
        $adjbin_baseline_mean_split_adj_read[$loopE]=0;
        $adjbin_baseline_SD_split_adj_read[$loopE]=0;
    } else { 
        $adjbin_baseline_mean_split_adj_read[$loopE]=int($SAdjBin/$nAdjBin*1000+0.5)/1000;
        $adjbin_baseline_SD_split_adj_read[$loopE]=int(sqrt(($SSAdjBin-$SAdjBin*$SAdjBin/$nAdjBin)/($nAdjBin-1))*1000+0.5)/1000;
    }
    if ($adjbin_baseline_mean_split_adj_read[$loopE]==0 || $adjbin_baseline_SD_split_adj_read[$loopE]==0) {$start_loopE=$loopE+1; } 
    #print "Mean baseline of adjbin data values: $adjbin_baseline_mean_split_adj_read[$loopE]\n";
    #print "ANOVA-based SD of mean baseline of adjbin data values: $adjbin_baseline_SD_split_adj_read[$loopE]\n";
    #print "Number of adjbin data values used to calculate mean and SD: $nAdjBin\n\n";
    #
}
#
#print "Bin\tNumber of adjust reads\tAdjbin Baseline SD\n";
for ($loopE=$start_loopE; $loopE<=$number_split_adj_read; $loopE++) {
    #print "$loopE\t\t$adjust_limit[$loopE]\t$adjbin_baseline_SD_split_adj_read[$loopE]\n";
    $linx[$loopE]=$adjust_limit[$loopE];
    $liny[$loopE]=$adjbin_baseline_SD_split_adj_read[$loopE];
    $logx[$loopE]=log($adjust_limit[$loopE]);
    $logy[$loopE]=log($adjbin_baseline_SD_split_adj_read[$loopE]);
}
#print "\n";
#
#
#
# assume data fit a power curve of the type:  y = a * x^b
#
# determine R2 and slope for multiple start positions of power curve, each with a fixed number of data points = $number_points_line
#
# conversion of power curve to linear:  log(y) = log(a) + b log(x)  =>   Y = A + b X 
#
#
#
$number_points_line=int($number_split_adj_read/4); # how many bins we will split the adjust reads into
if ($number_points_line<10) {
    print "Script Line 598: Number_points_line = $number_points_line too small. Increase number_split_adj_read in Line 515\n\n";
    exit;
}
#
for ($loopE=$start_loopE; $loopE<=$number_split_adj_read-$number_points_line+1; $loopE++) {
    #
    $SX=0;
    $SSX=0;
    $SY=0;
    $SSY=0;
    $SXY=0;
    $n=$number_points_line;
    #
    for ($loopD=1; $loopD<=$number_points_line; $loopD++) {
        $loop_now=$loopE+$loopD-1;
        $SX=$SX+$logx[$loop_now];
        $SSX=$SSX+($logx[$loop_now]*$logx[$loop_now]);
        $SY=$SY+$logy[$loop_now];
        $SSY=$SSY+($logy[$loop_now]*$logy[$loop_now]);
        $SXY=$SXY+($logx[$loop_now]*$logy[$loop_now]);
    }
    #
    # calculations
    #
    $SXSY=$SX*$SY;
    $SXMYM=$SXY-($SXSY/$n);
    $SXMXM=$SSX-($SX*$SX/$n);
    $SXM2=$SXMXM;
    $SYMYM=$SSY-($SY*$SY/$n);
    $SLOPE=$SXMYM/$SXMXM;
    $INTER=($SY-$SX*$SLOPE)/$n;
    $SSESLOPE=$SYMYM-$SLOPE*$SLOPE*$SXMXM;
    $SDSLOPE=sqrt($SSESLOPE/($n-2)/$SXMXM);
    $TTEST=$SLOPE/$SDSLOPE;
    $DF=$n-2;
    $SLOPE_log_eval[$loopE]=$SLOPE;
    # calculate R2
    $SST=$SSY;
    $SS_Regression=$SLOPE*$SXMYM;
    $SS_Residual=$SST-$SS_Regression-$SY*$SY/$n;
    $SSM=$SY*$SY/$n;
    $R2[$loopE]=$SS_Regression/($SS_Residual+$SS_Regression);
    #
} 
#
# evaluate power curve and define start position
#
$max_neg_SLOPE=0;
$max_R2=0;
$loopE_at_max_R2=0;
$loopE_at_max_neg_SLOPE=0;
for ($loopE=$start_loopE; $loopE<=$number_split_adj_read-$number_points_line+1; $loopE++) {
    if ($R2[$loopE]>$max_R2) { $max_R2=$R2[$loopE] ; $loopE_at_max_R2=$loopE }
    if ($SLOPE_log_eval[$loopE]<$max_neg_SLOPE) { $max_neg_SLOPE=$SLOPE_log_eval[$loopE] ; $loopE_at_max_neg_SLOPE=$loopE }
}
print "\nStep 2: Calculate SD at each genomic bin using background noise data and sequence coverage at each genomic bin:\n\n";
print "Define power curve (adjust_reads vs adjbin_SD)\n";
print "Number of data segments (points defining curve): $number_split_adj_read\n";
print "Max R2:          $max_R2      Segment of max R2:  $loopE_at_max_R2    Slope at this position:  $SLOPE_log_eval[$loopE_at_max_R2]\n";
print "Max neg slope:  $max_neg_SLOPE      Segment of max R2:  $loopE_at_max_neg_SLOPE    R2 at this position:  $R2[$loopE_at_max_neg_SLOPE]\n";
#
if ($loopE_at_max_neg_SLOPE==0) {
    print "\nNo negative slope, Curve not as expected, Exiting\n\n";
    exit;
}
#
$start_power_curve=0;
for ($loopE=$start_loopE; $loopE<=$number_split_adj_read-$number_points_line+1-10; $loopE++) {
    $add_10_R2=$R2[$loopE]+$R2[$loopE+1]+$R2[$loopE+2]+$R2[$loopE+3]+$R2[$loopE+4]+$R2[$loopE+5]+$R2[$loopE+6]+$R2[$loopE+7]+$R2[$loopE+8]+$R2[$loopE+9];
    if ($add_10_R2>$max_R2*4 && $SLOPE_log_eval[$loopE]<$max_neg_SLOPE*0.4) {
        $start_power_curve=$loopE;
        $loopE=$number_split_adj_read;
    }
}
#
if ($start_power_curve+5>=$number_split_adj_read-$number_points_line+1-10) {$start_power_curve=$number_split_adj_read-$number_points_line-15}
#
print "\nFirst segment of power curve:           $start_power_curve\n";
if ($start_power_curve==0) {
    print "\nCannot find start of power curve, Curve not as expected, Exiting\n\n";
    exit;
}
if ($start_power_curve!=$start_loopE) {
    print "WARNING: First segment should have been -$start_loopE-. Curve does not start as expected. Data quality may or may not be OK.\n\n";
}
#
# end position of power curve
#
$end_power_curve=$number_split_adj_read-5;
#
print "End position of power curve:             $end_power_curve\n";
print "Adjbin baseline SD at end position:      $adjbin_baseline_SD_split_adj_read[$end_power_curve]\n";
print "Adjbin baseline SD at last position:     $adjbin_baseline_SD_split_adj_read[$number_split_adj_read]\n\n";
#
# calculate power curve for all points used
#
$SX=0;
$SSX=0;
$SY=0;
$SSY=0;
$SXY=0;
$n=0;
#
for ($loopD=$start_power_curve; $loopD<=$end_power_curve; $loopD++) {
    $loop_now=$loopD;
    $SX=$SX+$logx[$loop_now];
    $SSX=$SSX+($logx[$loop_now]*$logx[$loop_now]);
    $SY=$SY+$logy[$loop_now];
    $SSY=$SSY+($logy[$loop_now]*$logy[$loop_now]);
    $SXY=$SXY+($logx[$loop_now]*$logy[$loop_now]);
    $n++;
}
#
$SXSY=$SX*$SY;
$SXMYM=$SXY-($SXSY/$n);
$SXMXM=$SSX-($SX*$SX/$n);
$SXM2=$SXMXM;
$SYMYM=$SSY-($SY*$SY/$n);
$SLOPE=$SXMYM/$SXMXM;
$INTER=($SY-$SX*$SLOPE)/$n;
$SSESLOPE=$SYMYM-$SLOPE*$SLOPE*$SXMXM;
$SDSLOPE=sqrt($SSESLOPE/($n-2)/$SXMXM);
$TTEST=$SLOPE/$SDSLOPE;
$DF=$n-2;
print "Power curve stats: (adjust reads start position: $start_power_curve  end position: $end_power_curve)\n";
print "SLOPE: $SLOPE  ";
print "t TEST: $TTEST  ";
print "NUMBER OF SAMPLES: $n  ";
# calculate R2
$SST=$SSY;
$SS_Regression=$SLOPE*$SXMYM;
$SS_Residual=$SST-$SS_Regression-$SY*$SY/$n;
$SSM=$SY*$SY/$n;
$R2_pow=$SS_Regression/($SS_Residual+$SS_Regression);
$SLOPE_pow=$SLOPE;
$INTER_pow=$INTER;
print "R2 (FRACTION OF VAR DUE TO REGR): $R2_pow\n\n";
#
# calculate linear curve for remaining points
#
$SX=0;
$SSX=0;
$SY=0;
$SSY=0;
$SXY=0;
$n=0;
#
for ($loopD=$end_power_curve+1; $loopD<=$number_split_adj_read; $loopD++) {
    $loop_now=$loopD;
    $SX=$SX+$linx[$loop_now];
    $SSX=$SSX+($linx[$loop_now]*$linx[$loop_now]);
    $SY=$SY+$liny[$loop_now];
    $SSY=$SSY+($liny[$loop_now]*$liny[$loop_now]);
    $SXY=$SXY+($linx[$loop_now]*$liny[$loop_now]);
    $n++;
}
#
$SXSY=$SX*$SY;
$SXMYM=$SXY-($SXSY/$n);
$SXMXM=$SSX-($SX*$SX/$n);
$SXM2=$SXMXM;
$SYMYM=$SSY-($SY*$SY/$n);
$SLOPE=$SXMYM/$SXMXM;
$INTER=($SY-$SX*$SLOPE)/$n;
$SSESLOPE=$SYMYM-$SLOPE*$SLOPE*$SXMXM;
$SDSLOPE=sqrt($SSESLOPE/($n-2)/$SXMXM);
$TTEST=$SLOPE/$SDSLOPE;
$DF=$n-2;
print "Linear curve stats: (adjust reads start position: $end_power_curve+1  end position: $number_split_adj_read)\n";
print "SLOPE: $SLOPE  ";
print "t TEST: $TTEST  ";
print "NUMBER OF SAMPLES: $n  ";
# calculate R2
$SST=$SSY;
$SS_Regression=$SLOPE*$SXMYM;
$SS_Residual=$SST-$SS_Regression-$SY*$SY/$n;
$SSM=$SY*$SY/$n;
$R2_lin=$SS_Regression/($SS_Residual+$SS_Regression);
print "R2 (FRACTION OF VAR DUE TO REGR): $R2_lin\n\n";
#
#
#
print "Validation of curve fitting:\n";
print "Bin\tNumber of adjust reads\tAdjbin Baseline SD\tFitted SD\n";
for ($loopE=1; $loopE<=$number_split_adj_read; $loopE++) {
    if ($adjust_limit[$loopE]>$adjust_limit[$end_power_curve]) {
        $log_adjust_limit=log($adjust_limit[$end_power_curve]);
    } else {
        $log_adjust_limit=log($adjust_limit[$loopE]);
    }
    $log_adjbin_baseline_SD_split_adj_read=$INTER_pow+$SLOPE_pow*$log_adjust_limit;
    $calc_adjbin_baseline_SD_split_adj_read=exp($log_adjbin_baseline_SD_split_adj_read);
    if ( $loopE<10 || $loopE==(int(($loopE)/10))*10 ) {
        print "$loopE\t\t$adjust_limit[$loopE]\t\t$adjbin_baseline_SD_split_adj_read[$loopE]\t\t$calc_adjbin_baseline_SD_split_adj_read\n";
    }
}
print "\n\n";
#
#
######################### 
#
#
# calculate sigma values for each genomic bin
#
#
$adjbin_total_hits=0;
$adjbin_mb_total_hits=0;
#
$counts_totalSD_zero=0;
#
$counts_bcf=0;   # bcf: below baseline cutoff
$counts_acf=0;   # acf: above baseline cutoff
$counts_icf=0;   # icf: in baseline cutoff
$counts_mcf=0;   # mcf: in baseline mean
#
$adjbin_total_hits_bcf=0;
$adjbin_total_hits_icf=0;
$adjbin_total_hits_mcf=0;
$adjbin_total_hits_acf=0;
$adjbin_mb_total_hits_bcf=0;
$adjbin_mb_total_hits_icf=0;
$adjbin_mb_total_hits_mcf=0;
$adjbin_mb_total_hits_acf=0;
#
$sigma_bin_totalSD_total_hits_bcf=0;
$sigma_bin_totalSD_total_hits_icf=0;
$sigma_bin_totalSD_total_hits_mcf=0;
$sigma_bin_totalSD_total_hits_acf=0;
$sigma_bin_mb_totalSD_total_hits_bcf=0;
$sigma_bin_mb_totalSD_total_hits_icf=0;
$sigma_bin_mb_totalSD_total_hits_mcf=0;
$sigma_bin_mb_totalSD_total_hits_acf=0;
#
#
#
#
for ($loopC=1; $loopC<=23; $loopC++){
    for ($loopA=0; $loopA<$chr_size[$loopC]; $loopA++) {
        if ($adjust[$loopC][$loopA]!=0) {
            #
            $adjbin_mb[$loopC][$loopA]=$adjbin[$loopC][$loopA]-$adjbin_baseline_mean;
            $adjbin_total_hits=$adjbin_total_hits+$adjbin[$loopC][$loopA];
            $adjbin_mb_total_hits=$adjbin_mb_total_hits+$adjbin_mb[$loopC][$loopA];
            #
            if ($adjust[$loopC][$loopA]>$adjust_limit[$end_power_curve]) {
                $log_adjust_limit=log($adjust_limit[$end_power_curve]);
            } else {
                $log_adjust_limit=log($adjust[$loopC][$loopA]);
            }
            $log_adjbin_baseline_SD_split_adj_read=$INTER_pow+$SLOPE_pow*$log_adjust_limit;
            $adjbin_SD[$loopC][$loopA]=exp($log_adjbin_baseline_SD_split_adj_read);
            #
            $sigma_bin_totalSD[$loopC][$loopA]=$adjbin[$loopC][$loopA]/$adjbin_SD[$loopC][$loopA];
            $sigma_bin_mb_totalSD[$loopC][$loopA]=$adjbin_mb[$loopC][$loopA]/$adjbin_SD[$loopC][$loopA]; #### variable to USE
            #
            # calculate various total values for bins above and below and near baseline cutoff 
            #
            if ($adjbin[$loopC][$loopA] <= $adjbin_baseline_cutoff) {
                $counts_bcf++;
                #
                $adjbin_total_hits_bcf=$adjbin_total_hits_bcf+$adjbin[$loopC][$loopA];
                $adjbin_mb_total_hits_bcf=$adjbin_mb_total_hits_bcf+$adjbin_mb[$loopC][$loopA];
                #
                $sigma_bin_totalSD_total_hits_bcf=$sigma_bin_totalSD_total_hits_bcf+$sigma_bin_totalSD[$loopC][$loopA];
                $sigma_bin_mb_totalSD_total_hits_bcf=$sigma_bin_mb_totalSD_total_hits_bcf+$sigma_bin_mb_totalSD[$loopC][$loopA];
                #
            } else {
                $counts_acf++;
                #
                $adjbin_total_hits_acf=$adjbin_total_hits_acf+$adjbin[$loopC][$loopA];
                $adjbin_mb_total_hits_acf=$adjbin_mb_total_hits_acf+$adjbin_mb[$loopC][$loopA];
                #
                $sigma_bin_totalSD_total_hits_acf=$sigma_bin_totalSD_total_hits_acf+$sigma_bin_totalSD[$loopC][$loopA];
                $sigma_bin_mb_totalSD_total_hits_acf=$sigma_bin_mb_totalSD_total_hits_acf+$sigma_bin_mb_totalSD[$loopC][$loopA];
                #
            }
            #
            if ($adjbin[$loopC][$loopA] > $adjbin_baseline_cutoff*0.95 && $adjbin[$loopC][$loopA] < $adjbin_baseline_cutoff*1.05) {
                $counts_icf++;
                #
                $adjbin_total_hits_icf=$adjbin_total_hits_icf+$adjbin[$loopC][$loopA];
                $adjbin_mb_total_hits_icf=$adjbin_mb_total_hits_icf+$adjbin_mb[$loopC][$loopA];
                #
                $sigma_bin_totalSD_total_hits_icf=$sigma_bin_totalSD_total_hits_icf+$sigma_bin_totalSD[$loopC][$loopA];
                $sigma_bin_mb_totalSD_total_hits_icf=$sigma_bin_mb_totalSD_total_hits_icf+$sigma_bin_mb_totalSD[$loopC][$loopA];
                #
            }
            #
            if ($adjbin[$loopC][$loopA] > $adjbin_baseline_mean*0.95 && $adjbin[$loopC][$loopA] < $adjbin_baseline_mean*1.05) {
                $counts_mcf++;
                #
                $adjbin_total_hits_mcf=$adjbin_total_hits_mcf+$adjbin[$loopC][$loopA];
                $adjbin_mb_total_hits_mcf=$adjbin_mb_total_hits_mcf+$adjbin_mb[$loopC][$loopA];
                #
                $sigma_bin_totalSD_total_hits_mcf=$sigma_bin_totalSD_total_hits_mcf+$sigma_bin_totalSD[$loopC][$loopA];
                $sigma_bin_mb_totalSD_total_hits_mcf=$sigma_bin_mb_totalSD_total_hits_mcf+$sigma_bin_mb_totalSD[$loopC][$loopA];
                #
            }
            #
        }
    }
}
#
$adjbin_total_hits=int($adjbin_total_hits+0.5);
$adjbin_mb_total_hits=int($adjbin_mb_total_hits+0.5);
#
print "Step 3: Calculate sigma values at each genomic bin:\n\n";
print "Total recalculated sample hits:  $bin_recalc_total_hits\n";
print "Total recalculated adjust hits:  $adjust_recalc_total_hits\n";
print "Correction factor from bin to adjbin: $Acorr_factor\n\n";
#
print "Total adjbin sample hits (adjbin):                                         $adjbin_total_hits\n";
print "Total adjbin sample minus mean baseline hits (adjbin_mb):                  $adjbin_mb_total_hits\n";
print "Number of bins with totalSD equal to zero: $counts_totalSD_zero\n\n";
#
# calculate various mean values for bins below and above baseline cutoff
#
$adjbin_mean_hits_bcf=$adjbin_total_hits_bcf/$counts_bcf;
$adjbin_mean_hits_acf=$adjbin_total_hits_acf/$counts_acf;
$adjbin_mean_hits_icf=$adjbin_total_hits_icf/$counts_icf;
$adjbin_mean_hits_mcf=$adjbin_total_hits_mcf/$counts_mcf;
#
$adjbin_mb_mean_hits_bcf=$adjbin_mb_total_hits_bcf/$counts_bcf;
$adjbin_mb_mean_hits_acf=$adjbin_mb_total_hits_acf/$counts_acf;
$adjbin_mb_mean_hits_icf=$adjbin_mb_total_hits_icf/$counts_icf;
$adjbin_mb_mean_hits_mcf=$adjbin_mb_total_hits_mcf/$counts_mcf;
#
$sigma_bin_totalSD_mean_hits_bcf=$sigma_bin_totalSD_total_hits_bcf/$counts_bcf;
$sigma_bin_totalSD_mean_hits_acf=$sigma_bin_totalSD_total_hits_acf/$counts_acf;
$sigma_bin_totalSD_mean_hits_icf=$sigma_bin_totalSD_total_hits_icf/$counts_icf;
$sigma_bin_totalSD_mean_hits_mcf=$sigma_bin_totalSD_total_hits_mcf/$counts_mcf;
#
$sigma_bin_mb_totalSD_mean_hits_bcf=$sigma_bin_mb_totalSD_total_hits_bcf/$counts_bcf;
$sigma_bin_mb_totalSD_mean_hits_acf=$sigma_bin_mb_totalSD_total_hits_acf/$counts_acf;
$sigma_bin_mb_totalSD_mean_hits_icf=$sigma_bin_mb_totalSD_total_hits_icf/$counts_icf;
$sigma_bin_mb_totalSD_mean_hits_mcf=$sigma_bin_mb_totalSD_total_hits_mcf/$counts_mcf;
#
$total_bins=$counts_bcf+$counts_acf;
$percent_counts_bcf=int($counts_bcf/$total_bins*100);
$percent_counts_acf=int($counts_acf/$total_bins*100);
#
print "Number of bins at or below baseline cutoff: $counts_bcf     Percent: $percent_counts_bcf\n";
print "Number of bins above baseline cutoff:       $counts_acf     Percent: $percent_counts_acf\n";
print "Total bins (with adjust non-zero):          $total_bins\n\n";
#
print "Adjbin values\n";
print "Mean adjbin value for bins below baseline cutoff:       $adjbin_mean_hits_bcf\n";
print "Mean adjbin value for bins at baseline mean:            $adjbin_mean_hits_mcf\n";
print "Mean adjbin value for bins at baseline cutoff:          $adjbin_mean_hits_icf\n";
print "Mean adjbin value for bins above baseline cutoff:       $adjbin_mean_hits_acf\n\n";
#
print "Mean adjbin_mb value for bins below baseline cutoff:    $adjbin_mb_mean_hits_bcf\n";
print "Mean adjbin_mb value for bins at baseline mean:         $adjbin_mb_mean_hits_mcf\n";
print "Mean adjbin_mb value for bins at baseline cutoff:       $adjbin_mb_mean_hits_icf\n";
print "Mean adjbin_mb value for bins above baseline cutoff:    $adjbin_mb_mean_hits_acf\n\n";
#
print "Sigma values\n";
print "Mean sigma (adjbin/total SD) for bins below baseline cutoff:      $sigma_bin_totalSD_mean_hits_bcf\n";
print "Mean sigma (adjbin/total SD) for bins at baseline mean:           $sigma_bin_totalSD_mean_hits_mcf\n";
print "Mean sigma (adjbin/total SD) for bins at baseline cutoff:         $sigma_bin_totalSD_mean_hits_icf\n";
print "Mean sigma (adjbin/total SD) for bins above baseline cutoff:      $sigma_bin_totalSD_mean_hits_acf\n";
print "Mean sigma (adjbin_mb/total SD) for bins below baseline cutoff:   $sigma_bin_mb_totalSD_mean_hits_bcf\n";
print "Mean sigma (adjbin_mb/total SD) for bins at baseline mean:        $sigma_bin_mb_totalSD_mean_hits_mcf\n";
print "Mean sigma (adjbin_mb/total SD) for bins at baseline cutoff:      $sigma_bin_mb_totalSD_mean_hits_icf\n";
print "Mean sigma (adjbin_mb/total SD) for bins above baseline cutoff:   $sigma_bin_mb_totalSD_mean_hits_acf\n\n";
#
print "\nStep 4: Process sigma values: interpolate, smoothen, trim, convert to log2:\n\n";
# interpolate data when one empty bin between two full bins
#    interpolated bins get values:   $adjust[$loopC][$loopA]=-1
#
$counts_interpolation=0;
for ($loopC=1; $loopC<=23; $loopC++){
    for ($loopA=2; $loopA<$chr_size[$loopC]; $loopA++) {
       if ($adjust[$loopC][$loopA-2]>0 && $adjust[$loopC][$loopA-1]==0 && $adjust[$loopC][$loopA]>0) {
           #
           $weight_pre  = $adjust[$loopC][$loopA-2] / ($adjust[$loopC][$loopA-2] + $adjust[$loopC][$loopA]);
           $weight_post = $adjust[$loopC][$loopA]   / ($adjust[$loopC][$loopA-2] + $adjust[$loopC][$loopA]);
           #
           $adjbin[$loopC][$loopA-1] = $adjbin[$loopC][$loopA-2]*$weight_pre + $adjbin[$loopC][$loopA]*$weight_post;
           $adjbin_mb[$loopC][$loopA-1] = $adjbin_mb[$loopC][$loopA-2]*$weight_pre + $adjbin_mb[$loopC][$loopA]*$weight_post;
           #
           $sigma_bin_totalSD[$loopC][$loopA-1] = $sigma_bin_totalSD[$loopC][$loopA-2]*$weight_pre + $sigma_bin_totalSD[$loopC][$loopA]*$weight_post;
           $sigma_bin_mb_totalSD[$loopC][$loopA-1] = $sigma_bin_mb_totalSD[$loopC][$loopA-2]*$weight_pre + $sigma_bin_mb_totalSD[$loopC][$loopA]*$weight_post;
           #
           $adjust[$loopC][$loopA-1]=-1;
           $counts_interpolation++;
       }
    }
}
print "Number of bins interpolated:            $counts_interpolation\n";
#
# smoothen adjbin, sigma values
#
#   if central value below  adjbin_cutoff  and either of the side values is above  adjbin_cutoff  do not smoothen  
#
$counts_sm=0;
for ($loopC=1; $loopC<=23; $loopC++){
    for ($loopA=1; $loopA<$chr_size[$loopC]-1; $loopA++) {
        #
        $sigma_bin_totalSD_sm[$loopC][$loopA]=$sigma_bin_totalSD[$loopC][$loopA];
        $sigma_bin_mb_totalSD_sm[$loopC][$loopA]=$sigma_bin_mb_totalSD[$loopC][$loopA];
        #
        if ($adjust[$loopC][$loopA-1]!=0 && $adjust[$loopC][$loopA]!=0 && $adjust[$loopC][$loopA+1]!=0) {
            if ( ($adjbin[$loopC][$loopA-1]>$adjbin_baseline_cutoff || $adjbin[$loopC][$loopA+1]>$adjbin_baseline_cutoff) && $adjbin[$loopC][$loopA]<=$adjbin_baseline_cutoff ) {
                $donothing=0;
            } else {
                #
                $weight_pre  = $adjust[$loopC][$loopA-1] / ($adjust[$loopC][$loopA-1] + $adjust[$loopC][$loopA]*4 + $adjust[$loopC][$loopA+1]);
                $weight_now  = $adjust[$loopC][$loopA]*4 / ($adjust[$loopC][$loopA-1] + $adjust[$loopC][$loopA]*4 + $adjust[$loopC][$loopA+1]);
                $weight_post = $adjust[$loopC][$loopA+1] / ($adjust[$loopC][$loopA-1] + $adjust[$loopC][$loopA]*4 + $adjust[$loopC][$loopA+1]);
                #
                $sigma_bin_totalSD_sm[$loopC][$loopA]=$sigma_bin_totalSD[$loopC][$loopA-1]*$weight_pre+$sigma_bin_totalSD[$loopC][$loopA]*$weight_now+$sigma_bin_totalSD[$loopC][$loopA+1]*$weight_post;
                $sigma_bin_mb_totalSD_sm[$loopC][$loopA]=$sigma_bin_mb_totalSD[$loopC][$loopA-1]*$weight_pre+$sigma_bin_mb_totalSD[$loopC][$loopA]*$weight_now+$sigma_bin_mb_totalSD[$loopC][$loopA+1]*$weight_post;
                #
                $counts_sm++;
                #
            }
        }
    }
}
print "Number of sigma bins smoothened:        $counts_sm\n";
#
# $sigma_bin_totalSD    $sigma_bin_mb_totalSD 
#
$counts_tm=0;
for ($loopC=1; $loopC<=23; $loopC++){
    for ($loopA=1; $loopA<$chr_size[$loopC]-1; $loopA++) {
        $sigma_bin_totalSD_tm[$loopC][$loopA]=$sigma_bin_totalSD[$loopC][$loopA];
        $sigma_bin_mb_totalSD_tm[$loopC][$loopA]=$sigma_bin_mb_totalSD[$loopC][$loopA];
        if ($adjust[$loopC][$loopA-1]!=0 && $adjust[$loopC][$loopA]!=0 && $adjust[$loopC][$loopA+1]!=0) {
            #
            if ($sigma_bin_mb_totalSD[$loopC][$loopA]>$sigma_bin_mb_totalSD[$loopC][$loopA-1]*1.2 && $sigma_bin_mb_totalSD[$loopC][$loopA]>$sigma_bin_mb_totalSD[$loopC][$loopA+1]*1.2) {
                #
                if ($sigma_bin_totalSD[$loopC][$loopA-1]>=$sigma_bin_totalSD[$loopC][$loopA+1]) {
                    $sigma_bin_totalSD_tm[$loopC][$loopA]=$sigma_bin_totalSD[$loopC][$loopA-1]*1.2;
                } else {
                    $sigma_bin_totalSD_tm[$loopC][$loopA]=$sigma_bin_totalSD[$loopC][$loopA+1]*1.2;
                }
                #
                if ($sigma_bin_mb_totalSD[$loopC][$loopA-1]>=$sigma_bin_mb_totalSD[$loopC][$loopA+1]) {
                    $sigma_bin_mb_totalSD_tm[$loopC][$loopA]=$sigma_bin_mb_totalSD[$loopC][$loopA-1]*1.2;
                } else {
                    $sigma_bin_mb_totalSD_tm[$loopC][$loopA]=$sigma_bin_mb_totalSD[$loopC][$loopA+1]*1.2;
                }
                #
                $counts_tm++;
            }
            #
        }
    }
}
print "Number of sigma bins trimmed:           $counts_tm\n\n";
#
# convert  sigma_bin_mb  to log2 (non-smoothened, smoothened, trimmed)
#   after log conversion want log2 of  $sigma_bin_mb_totalSD_mean_hits_mcf  to be equal to zero (as it is before log2 conversion)
#      hence need to add a constant value to all   $sigma_bin_mb_totalSD   values
#
$adj_to_log2=1-$sigma_bin_mb_totalSD_mean_hits_mcf;
#
if ($sigma_bin_mb_totalSD_mean_hits_icf+$adj_to_log2>1) { 
    $sigma_bin_mb_totalSD_mean_hits_icf_log2 = log($sigma_bin_mb_totalSD_mean_hits_icf+$adj_to_log2)/log(2);
} else {
    $sigma_bin_mb_totalSD_mean_hits_icf_log2 = 0;
}
#
if ($sigma_bin_mb_totalSD_mean_hits_acf+$adj_to_log2>1) { 
    $sigma_bin_mb_totalSD_mean_hits_acf_log2 = log($sigma_bin_mb_totalSD_mean_hits_acf+$adj_to_log2)/log(2);
} else {
    $sigma_bin_mb_totalSD_mean_hits_acf_log2 = 0;
}
#
for ($loopC=1; $loopC<=23; $loopC++){
    for ($loopA=0; $loopA<$chr_size[$loopC]; $loopA++) {
        if ($adjust[$loopC][$loopA]!=0) {
            #
            if ($sigma_bin_mb_totalSD[$loopC][$loopA]+$adj_to_log2>1)    { $sigma_bin_mb_totalSD_log2[$loopC][$loopA] =    log($sigma_bin_mb_totalSD[$loopC][$loopA]+$adj_to_log2)/log(2)    }
            if ($sigma_bin_mb_totalSD_sm[$loopC][$loopA]+$adj_to_log2>1) { $sigma_bin_mb_totalSD_sm_log2[$loopC][$loopA] = log($sigma_bin_mb_totalSD_sm[$loopC][$loopA]+$adj_to_log2)/log(2) }
            if ($sigma_bin_mb_totalSD_tm[$loopC][$loopA]+$adj_to_log2>1) { $sigma_bin_mb_totalSD_tm_log2[$loopC][$loopA] = log($sigma_bin_mb_totalSD_tm[$loopC][$loopA]+$adj_to_log2)/log(2) }
            #
        }
    }
}
#
# find maximum values for  tm_log2  scale
#
@max_sigma_bin_mb_totalSD_tm_log2=();
#
for ($loopC=1; $loopC<=23; $loopC++){
    for ($loopA=0; $loopA<$chr_size[$loopC]; $loopA++) {
        if ($adjust[$loopC][$loopA]!=0) {
            #
            push(@max_sigma_bin_mb_totalSD_tm_log2,$sigma_bin_mb_totalSD_tm_log2[$loopC][$loopA]);
            #
        }
    }
}
#
@sort_max_sigma_bin_mb_totalSD_tm_log2 = sort { $a <=> $b } @max_sigma_bin_mb_totalSD_tm_log2;  
#
$n=$#sort_max_sigma_bin_mb_totalSD_tm_log2;
$sigma_bin_mb_totalSD_tm_log2_max_hit=int($sort_max_sigma_bin_mb_totalSD_tm_log2[$n]*1000+0.5)/1000;
$sigma_bin_mb_totalSD_tm_log2_top10_hits=int(($sort_max_sigma_bin_mb_totalSD_tm_log2[$n-5]+$sort_max_sigma_bin_mb_totalSD_tm_log2[$n-10]+$sort_max_sigma_bin_mb_totalSD_tm_log2[$n-15]+$sort_max_sigma_bin_mb_totalSD_tm_log2[$n-20])*250+0.5)/1000;
#
#
#
# calculate t6 variables to leave only top6 log2 values from  smoothened adjbin_log2 peaks
#
#for ($loopC=1; $loopC<=23; $loopC++){
#    for ($loopA=0; $loopA<$chr_size[$loopC]; $loopA++) {
#        if ($adjust[$loopC][$loopA]!=0) {
#            #
#            $adjbin_smt6_log2[$loopC][$loopA]=$adjbin_sm_log2[$loopC][$loopA]-$adjbin_sm_top10_hits_log2+6;
#            if ($adjbin_smt6_log2[$loopC][$loopA]<0) {$adjbin_smt6_log2[$loopC][$loopA]=0}
#            #
#        }
#    }
#}
#
print "Log2 conversions\n";
print "Log2 of mean sigma (bin_mb/total SD) for bins at baseline mean:        set to 0\n";
print "Log2 of mean sigma (bin_mb/total SD) for bins at baseline cutoff:      $sigma_bin_mb_totalSD_mean_hits_icf_log2\n";
print "Log2 of mean sigma (bin_mb/total SD) for bins above baseline cutoff:   $sigma_bin_mb_totalSD_mean_hits_acf_log2\n";
print "Log2 of max sigma value (tm):                                          $sigma_bin_mb_totalSD_tm_log2_max_hit\n";
print "Log2 of top 10 sigma values (tm):                                      $sigma_bin_mb_totalSD_tm_log2_top10_hits\n\n";
#
# limit decimals
#
for ($loopC=1; $loopC<=23; $loopC++){
    for ($loopA=0; $loopA<$chr_size[$loopC]; $loopA++) {
        #
        $adjbin_SD[$loopC][$loopA]=int($adjbin_SD[$loopC][$loopA]*1000+0.5)/1000;
        #
        $adjbin[$loopC][$loopA]=int($adjbin[$loopC][$loopA]*1000+0.5)/1000;
        $adjbin_mb[$loopC][$loopA]=int($adjbin_mb[$loopC][$loopA]*1000+0.5)/1000;
        #
        $sigma_bin_totalSD[$loopC][$loopA]=int($sigma_bin_totalSD[$loopC][$loopA]*1000+0.5)/1000;
        $sigma_bin_totalSD_sm[$loopC][$loopA]=int($sigma_bin_totalSD_sm[$loopC][$loopA]*1000+0.5)/1000;
        $sigma_bin_totalSD_tm[$loopC][$loopA]=int($sigma_bin_totalSD_tm[$loopC][$loopA]*1000+0.5)/1000;
        $sigma_bin_mb_totalSD[$loopC][$loopA]=int($sigma_bin_mb_totalSD[$loopC][$loopA]*1000+0.5)/1000;
        $sigma_bin_mb_totalSD_sm[$loopC][$loopA]=int($sigma_bin_mb_totalSD_sm[$loopC][$loopA]*1000+0.5)/1000;
        $sigma_bin_mb_totalSD_tm[$loopC][$loopA]=int($sigma_bin_mb_totalSD_tm[$loopC][$loopA]*1000+0.5)/1000;
        #
        $sigma_bin_mb_totalSD_log2[$loopC][$loopA]=int($sigma_bin_mb_totalSD_log2[$loopC][$loopA]*1000+0.5)/1000;             
        $sigma_bin_mb_totalSD_sm_log2[$loopC][$loopA]=int($sigma_bin_mb_totalSD_sm_log2[$loopC][$loopA]*1000+0.5)/1000;           
        $sigma_bin_mb_totalSD_tm_log2[$loopC][$loopA]=int($sigma_bin_mb_totalSD_tm_log2[$loopC][$loopA]*1000+0.5)/1000; 
        #
    }
}
#
# write files 
#
print "\nStep 5: Write sigma files (3 files written):\n\n";

$result_File = join("",$temp_file_name1[0],"sigma_all_0b.csv");
#
open RESULT, "> $result_File";
#
for ($loopA=0; $loopA<$max_number_bins; $loopA++) {
   for ($loopC=1; $loopC<=23; $loopC++){
       #
       printf RESULT "$sigma_bin_mb_totalSD_sm[$loopC][$loopA],$sigma_bin_mb_totalSD_tm[$loopC][$loopA],";                    #variables 0-1
       printf RESULT "$sigma_bin_totalSD_sm[$loopC][$loopA],$sigma_bin_totalSD_tm[$loopC][$loopA],$adjust[$loopC][$loopA],";  #variables 2-4
       printf RESULT "$sigma_bin_mb_totalSD[$loopC][$loopA],$sigma_bin_totalSD[$loopC][$loopA],"; #variables 5-6
       printf RESULT "$sigma_bin_mb_totalSD_log2[$loopC][$loopA],$sigma_bin_mb_totalSD_sm_log2[$loopC][$loopA],$sigma_bin_mb_totalSD_tm_log2[$loopC][$loopA],"; #variables 7-9
       printf RESULT "$adjbin[$loopC][$loopA],$adjbin_mb[$loopC][$loopA],"; #variables 10-11
       printf RESULT "$adjbin_SD[$loopC][$loopA],$bin[$loopC][$loopA],,"; #variable 12-13
   }
   printf RESULT "\n";
}
#
close RESULT;
#
#
#
$result_File = join("",$temp_file_name1[0],"sigma_select_0b.csv");
#
open RESULT, "> $result_File";
#
for ($loopA=0; $loopA<$max_number_bins; $loopA++) {
   for ($loopC=1; $loopC<=23; $loopC++){
       #
       printf RESULT "$sigma_bin_mb_totalSD_sm[$loopC][$loopA],$sigma_bin_mb_totalSD_tm[$loopC][$loopA],";                   #variables 0-1
       printf RESULT "$sigma_bin_totalSD_sm[$loopC][$loopA],$sigma_bin_totalSD_tm[$loopC][$loopA],$adjust[$loopC][$loopA],,"; #variables 2-4
       #
   }
   printf RESULT "\n";
}
#
close RESULT;
#
#
#
$result_File = join("",$temp_file_name1[0],"sigma_qual_counts_0b.txt");
#print "$result_File\n";
#
open RESULT, "> $result_File";
#
printf RESULT "\n";
#
printf RESULT "File Name: $file_Name\n";
printf RESULT "Bin size: $bin_size\n";
printf RESULT "Max number of bins: $max_number_bins\n";
printf RESULT "Total sample hits: $bin_total_hits\n";
printf RESULT "Total adjust hits: $adjust_total_hits\n";
printf RESULT "Correction factor from bin to adjbin: $Acorr_factor\n\n";
#
printf RESULT "Percentile at low baseline cutoff: $percentile_baseline_cutoff_low\n";
printf RESULT "Baseline of adjbin data values at low cutoff: $adjbin_baseline_cutoff_low\n\n";
#
printf RESULT "Percentile at high baseline cutoff: $percentile_baseline_cutoff_high\n";
printf RESULT "Baseline of adjbin data values at high cutoff: $adjbin_baseline_cutoff_high\n\n";
#
printf RESULT "Baseline of adjbin data values (selected baseline cutoff): $adjbin_baseline_cutoff\n";
printf RESULT "Percentile at baseline: $percentile_baseline_cutoff\n";
printf RESULT "Percentile used to calculate SD of baseline\n (should be equal to percentile at baseline): $used_percentile_baseline\n";
printf RESULT "Mean baseline of adjbin data values: $adjbin_baseline_mean\n";
printf RESULT "ANOVA-based SD of mean baseline of adjbin data values: $adjbin_baseline_SD\n";
printf RESULT "Number of adjbin data values used to calculate mean and SD: $nAdjBin\n";
#
printf RESULT "Total recalculated sample hits:  $bin_recalc_total_hits\n";
printf RESULT "Total recalculated adjust hits:  $adjust_recalc_total_hits\n";
printf RESULT "Correction factor from bin to adjbin: $Acorr_factor\n\n";
#
printf RESULT "Total adjbin sample hits (adjbin):                                         $adjbin_total_hits\n";
printf RESULT "Total adjbin sample minus mean baseline hits (adjbin_mb):                  $adjbin_mb_total_hits\n";
printf RESULT "Number of bins with totalSD equal to zero:    $counts_totalSD_zero\n\n";
#
printf RESULT "Number of bins at or below baseline cutoff: $counts_bcf     Percent: $percent_counts_bcf\n";
printf RESULT "Number of bins above baseline cutoff:       $counts_acf     Percent: $percent_counts_acf\n";
printf RESULT "Total bins (with adjust non-zero):          $total_bins\n\n";
#
printf RESULT "Adjbin values\n";
printf RESULT "Mean adjbin value for bins below baseline cutoff:       $adjbin_mean_hits_bcf\n";
printf RESULT "Mean adjbin value for bins at baseline mean:            $adjbin_mean_hits_mcf\n";
printf RESULT "Mean adjbin value for bins at baseline cutoff:          $adjbin_mean_hits_icf\n";
printf RESULT "Mean adjbin value for bins above baseline cutoff:       $adjbin_mean_hits_acf\n\n";
#
printf RESULT "Mean adjbin_mb value for bins below baseline cutoff:    $adjbin_mb_mean_hits_bcf\n";
printf RESULT "Mean adjbin_mb value for bins at baseline mean:         $adjbin_mb_mean_hits_mcf\n";
printf RESULT "Mean adjbin_mb value for bins at baseline cutoff:       $adjbin_mb_mean_hits_icf\n";
printf RESULT "Mean adjbin_mb value for bins above baseline cutoff:    $adjbin_mb_mean_hits_acf\n\n";
#
printf RESULT "Sigma values\n";
printf RESULT "Mean sigma (adjbin/total SD) for bins below baseline cutoff:      $sigma_bin_totalSD_mean_hits_bcf\n";
printf RESULT "Mean sigma (adjbin/total SD) for bins at baseline mean:           $sigma_bin_totalSD_mean_hits_mcf\n";
printf RESULT "Mean sigma (adjbin/total SD) for bins at baseline cutoff:         $sigma_bin_totalSD_mean_hits_icf\n";
printf RESULT "Mean sigma (adjbin/total SD) for bins above baseline cutoff:      $sigma_bin_totalSD_mean_hits_acf\n";
printf RESULT "Mean sigma (adjbin_mb/total SD) for bins below baseline cutoff:   $sigma_bin_mb_totalSD_mean_hits_bcf\n";
printf RESULT "Mean sigma (adjbin_mb/total SD) for bins at baseline mean:        $sigma_bin_mb_totalSD_mean_hits_mcf\n";
printf RESULT "Mean sigma (adjbin_mb/total SD) for bins at baseline cutoff:      $sigma_bin_mb_totalSD_mean_hits_icf\n";
printf RESULT "Mean sigma (adjbin_mb/total SD) for bins above baseline cutoff:   $sigma_bin_mb_totalSD_mean_hits_acf\n\n";
#
printf RESULT "Number of bins interpolated:            $counts_interpolation\n";
printf RESULT "Number of adjbin/sigma bins smoothened: $counts_sm\n";
printf RESULT "Number of sigma bins trimmed:           $counts_tm\n\n";
#
printf RESULT "Log2 conversions\n";
printf RESULT "Log2 of mean sigma (adjbin_mb/total SD) for bins at baseline mean:        set to 0\n";
printf RESULT "Log2 of mean sigma (adjbin_mb/total SD) for bins at baseline cutoff:      $sigma_bin_mb_totalSD_mean_hits_icf_log2\n";
printf RESULT "Log2 of mean sigma (adjbin_mb/total SD) for bins above baseline cutoff:   $sigma_bin_mb_totalSD_mean_hits_acf_log2\n";
printf RESULT "Log2 of max sigma value (tm):                                             $sigma_bin_mb_totalSD_tm_log2_max_hit\n";
printf RESULT "Log2 of top 10 sigma values (tm):                                         $sigma_bin_mb_totalSD_tm_log2_top10_hits\n\n";
#
#
#
close RESULT;
#
#
#
exit;
#
#

