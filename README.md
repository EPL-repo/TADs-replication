# TADs-replication

> Data for Puig Lombardi & Tarsounas manuscript: Early S-phase replication origin firing within topologically associating domain boundaries is defined by transcription

---

## Contents

> Directory details

- [CSV_files](#CSVfiles)
- [REPLIseq](#REPLIseq)
- [SNSseq_origins](#SNSseq)
- [Average_plots_matrices](#matrices)
- [Permutations_tests](#permutations)

---

## CSV_files

- These are the EdUseq-HU analysis outputs, files prepared using bwa-mem and the Perl scripts in the directory Perl_scripts_Macheret-Halazonetis_2018/
- Raw sequencing data can be found [here](https://www.ncbi.nlm.nih.gov/bioproject/PRJNA397123) for U2OS cells and [here](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE153734) for H1299 cells
- Reads must be aligned to the human **masked** genome (version: GRCh37/hg19), accessed from [here](http://hgdownload.soe.ucsc.edu/goldenPath/hg19/bigZips/)

```shell
$ bwa mem -M -t 4 hg19.masked EdUseq_expt.fastq > EdUseq_expt.sam

### Use only the reads (100nt) with the highest quality score (here, we used 37 for U2OS samples and 60 for H1299 samples) to calculate the number of reads per 10-Kb (kilobase) bin:
$ perl calculate_number_hits_per_bin_v1.pl 10000 37 100 EdUseq_expt.sam

### Requires that the following files, generated by calculate_number_hits_per_bin_v1.pl, are in same directory: "*_adjbin_0b.csv" and matching "*_adjbin_qual_counts_0b.txt"
$ perl calculate_sigma_from_number_hits_per_bin_v1.pl EdUseq_expt_bin-size_10000_quality_37_chr1-X_adjbin_0b.csv

```

General format of the CSV files:\
25,000 lines corresponding to each of the 10-Kb (kilobase) bin partitions of a given chromosome\
Line 1: nucleotides 1-9,999 = bin: 0;\
Line 2: nucleotides 10,000-19,999 = bin: 1;\
[...]\
Each line contains data for 22 or 23 chromosomes (chr1-22, and depending on the cell line also chrX),\
and each column contains a variable:\
chr_1_variable_1, chr_1_variable_2, chr_1_variable_n,,chr_2_variable_1, chr_2_variable_2, chr_2_variable_n,, etc...\
\
Variables include (detailed in the plot_sigma_values_v1.pl Perl script):\
1 = $sigma_bin_mb_totalSD_sm:       sigma value with background (noise) subtraction, all values smoothened\
2 = $sigma_bin_mb_totalSD_tm:       sigma value with background (noise) subtraction, high values trimmed\
3 = $sigma_bin_totalSD_sm:          sigma value without background (noise) subtraction, all values smoothened\
4 = $sigma_bin_totalSD_tm:          sigma value without background (noise) subtraction, high values trimmed\
5 = $adjust:                        sequence coverage of genomic DNA sequencing (reflecting all sequencing biases)\
6 = $sigma_bin_mb_totalSD:          sigma value with background (noise) subtraction\
7 = $sigma_bin_totalSD:             sigma value without background (noise) subtraction\
8 = $sigma_bin_mb_totalSD_log2:     sigma value with background (noise) subtraction, converted to log2\
9 = $sigma_bin_mb_totalSD_sm_log2:  sigma value with background (noise) subtraction, all values smoothened, converted to log2\
10 = $sigma_bin_mb_totalSD_tm_log2: sigma value with background (noise) subtraction, high values trimmed, converted to log2\
11 = $adjbin:                       number of sequences per bin, adjusted for all sequencing biases (using $adjust)\
12 = $adjbin_mb:                    number of sequences per bin with background (noise) subtraction, adjusted for all sequencing biases (using $adjust)\
13 = $adjbin_SD:                    standard deviation of adjbin values\
14 = $bin:                          number of sequences per bin\

---

## REPLIseq

- Raw sequencing data can be found [here](https://www.ncbi.nlm.nih.gov/bioproject/PRJNA397123)

The early, mid and late S-phase REPLIseq reads were assigned to 10-Kb genomic bins.\
The numbers of early, mid and late S-phase reads were compared for each genomic bin: if one fraction (early, mid or late) accounted for more than 50% of the total reads for the bin, then that bin was assigned to the corresponding replication timing domain:

```shell
### Make 10kb windows for count bins
$ sort -k1,1 -k2,2n hg19.chrom.sizes > hg19_sorted.chrom.sizes
$ bedtools makewindows -w 10000 -s 10000 -g hg19_sorted.chrom.sizes > hg19_windows.bed

### Process fastq
$ for file in *.fastq
> do
>	INPUT=${file:0:17}
>	### BWA alignment
>	bwa mem -M -t 4 hg19.masked $file > $INPUT.sam
>	### SAM to BAM
>	samtools view -bSq 20 $INPUT.sam > $INPUT.bam
>	### Sort BAM
>	samtools sort -o $INPUT.srt.bam $INPUT.bam
>	### Remove duplicates
>	samtools rmdup -S $INPUT.srt.bam $INPUT.rmdup.bam
>	### BAM to BED
>	bamToBed -i $INPUT.rmdup.bam > $INPUT.bed
>	### Sort BED
>	sort -k1,1 -k2,2n $INPUT.bed > $INPUT.srt.bed
>	### Counts per bin
>	bedtools intersect -sorted -c -b $INPUT.srt.bed -a hg19_windows.bed > $INPUT.windows.bed
>	### Make BEDGRAPH file
>	awk '{printf "%s\t%d\t%d\t%2.3f\n", $1,$2,$3,$4}' $INPUT.windows.bed > $INPUT.bg
>done

### Calculate count ratios (Early/Mid/Late), e.g. replicate 1 (rep1) data
$ paste U2OS_NE_rep1_E_.bg U2OS_NE_rep1_M_.bg U2OS_NE_rep1_L_.bg | \
awk '{if($8 != 0 || $4 != 0 || $12 != 0){print $1,$2,$3,$4,$8,$12,$4/($4+$8+$12),$8/($4+$8+$12),$12/($4+$8+$12)}}' \
OFS='\t' > U2OS_NE_rep1_EML-ratios_.bg
```
\
R
```{r}

tab <- read.table("U2OS_NE_rep1_EML-ratios_.bg",h=F,sep="\t")
colnames(tab) <- c("chr","start","end","E_counts","M_counts","L_counts","E_prop","M_prop","L_prop")

tab$RT <- rep("0",nrow(tab))
for(i in 1:nrow(tab)){
	if(tab$E_prop[i] > tab$M_prop[i] & tab$E_prop[i] > tab$L_prop[i]){
		tab$RT[i] <- "E"
	}
	else if(tab$M_prop[i] > tab$E_prop[i] & tab$M_prop[i] > tab$L_prop[i]){
		tab$RT[i] <- "M"	
	}
	else if(tab$L_prop[i] > tab$E_prop[i] & tab$L_prop[i] > tab$M_prop[i]){
		tab$RT[i] <- "L"	
	}	
	else{tab$RT[i] <- "U"}
}

tab$RT <- as.factor(tab$RT)

tbl <- tab[,c("chr","start","end","E_prop","M_prop","L_prop","RT")]

tbl$ratio <- rep("0",nrow(tbl))
for(i in 1:nrow(tbl)){
	if(tbl$RT[i] == "E"){
		tbl$ratio[i] <- tbl$E_prop[i]
	}
	else if(tbl$RT[i] == "M"){
		tbl$ratio[i] <- tbl$M_prop[i]
	}
	else if(tbl$RT[i] == "L"){
		tbl$ratio[i] <- tbl$L_prop[i]
	}
	else{tbl$ratio[i] <- 0}
}

tblRT <- tbl[,c(1,2,3,7,8)]

write.table(tblRT,"U2OS_NE_rep1_RT.txt",sep="\t", quote=F, row.names=F)

```
\
To make Early/Late profiles (using 10kb windows, following Marchal et al. Nature Protocols 2018):
```shell
for file in *_E_.bg
do
paste $file ${file%E_.bg}L_.bg | awk '{if($8 != 0 && $4 != 0){print $1,$2,$3,log($4/$8)/log(2)}}' \
OFS='\t' > ${file%E_.bg}T_.bg
done

### alternative (including $V4=0 bins)
for file in *_E_.bg
do
paste $file ${file%E_.bg}L_.bg | awk '{if($8 != 0){print $1,$2,$3,log($4/$8)/log(2)}}' \
OFS='\t' > ${file%E_.bg}T_.bg
done

echo -e "chr\tstart\tstop\t" ls *_T_.bg | sed 's/\ /\t/g' > merge_RT.txt
cat *_T_.bg >> merge_RT.txt
```
\
R (for Loess smoothing and bedgraph file creation)

```{r}
library(preprocessCore)

merge <- read.table("merge_RT.txt", header=TRUE)
merge_values <- as.matrix(merge[,4:ncol(merge)])

### Quantile normalization
ad <- merge[,"U2OS_NE_T_.bg"]

norm_data <- normalize.quantiles.use.target(merge_values,ad)
merge_norm <- data.frame(merge[,1:3],norm_data)
colnames(merge_norm) <- colnames(merge)

for(i in 4:ncol(merge_norm)){
	write.table(merge_norm[complete.cases(merge_norm[,i]), c(1,2,3,i)],
	gsub(".bg", "qnorm.bedGraph", colnames(merge_norm)[i]), sep= "\t",row.names=FALSE,
	quote=FALSE, col.names = FALSE)
}

### Loess smoothing
chrs <- grep(levels(merge_norm$chr),pattern= "[_YM]",invert=TRUE,value=TRUE) #select chr (not Y, not MT)

AllLoess=list()
for(i in 1:(ncol(merge_norm)-3)){
	AllLoess[[i]]=data.frame();
	cat("Current dataset:", colnames(merge_norm)[i+3], "\n");
	for(Chr in chrs){
		RTb=subset(merge_norm, merge_norm$chr==Chr);
		lspan= 300000/(max(RTb$start)-min(RTb$start));
		cat("Current chrom:", Chr, "\n");
		RTla=loess(RTb[,i+3] ~ RTb$start, span=lspan);
		RTl=data.frame(c(rep(Chr,times=RTla$n)), RTla$x, merge_norm[which(merge_norm$chr==Chr & merge_norm$start %in% RTla$x),3],RTla$fitted);
		colnames(RTl)=c("chr", "start", "end",colnames(RTb)[i+3]);
		if(length(AllLoess[[i]])!=0){
			AllLoess[[i]]=rbind(AllLoess[[i]],RTl)
		};
		if(length(AllLoess[[i]])==0){
			AllLoess[[i]] = RTl
		}
	}
}

### Write Loess-smoothed bedgraph file	
for(i in 1:length(AllLoess)){
	write.table(AllLoess[[i]][complete.cases(AllLoess[[i]]),], gsub(".bg", "Loess.bedgraph",
	colnames(AllLoess[[i]]))[4], sep= "\t", row.names=FALSE, quote=FALSE, col.names = FALSE)
}

### Plot a single chromosome to inspect the data (e.g. chromosome 1)
df <- as.data.frame(AllLoess)
chr1 <- df[which(df$chr=="chr1"),]
par(mar=c(3.1,4.1,1,1))
plot(chr1[,4],pch=19,cex=0.2,col="grey",ylim=c(-6,6),ylab="RT",xaxt="n")
```

---

## SNSseq_origins

- Raw SNSseq data can be found [here](https://www.ncbi.nlm.nih.gov/bioproject/PRJNA163241) for HeLa cells and [here](https://www.ncbi.nlm.nih.gov/bioproject/PRJNA257527) for non-replicating genomic DNA (LexoG0) in MCF7 cells

Peaks were called using the MACS2 *callpeak* function with the following parameters: *--gsize hs --bw 300 --qvalue 0.05 --mfold 5 50* and using LexoG0 uniquely mapped reads (in triplicate) as a control.\
Only origins detected in both HeLa SNS replicates were retained: see the intersection_HeLa_SNSseq.narrowPeak file.

---

## Average_plots_matrices

Matrices generated using the [deeptools](https://deeptools.readthedocs.io/en/develop/index.html) *computeMatrix* function in the *scale-regions* mode, serving to subsequently create average origin firing plots over TADs.

---

## Permutations_tests

Graphical output of circular permutations tests (n = 10,000 iterations).\
\
Tests were performed using the [regioneR](http://bioconductor.org/packages/release/bioc/html/regioneR.html) R/Bioconductor package.\
\
Basic requirements:\
BSgenome.Hsapiens.UCSC.hg19 (≥v1.4.0)\
regioneR (≥v1.18.1)


